{"meta":{"title":"Passion's Blog","subtitle":"","description":"","author":"Passion","url":"https://pass1on.fun","root":"/"},"pages":[{"title":"categories","date":"2021-12-18T02:33:04.000Z","updated":"2022-01-25T17:03:30.215Z","comments":true,"path":"categories/index.html","permalink":"https://pass1on.fun/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-01-01T00:34:55.000Z","updated":"2022-03-06T15:07:04.814Z","comments":true,"path":"about/index.html","permalink":"https://pass1on.fun/about/index.html","excerpt":"","text":"欢迎来访我的博客，本站使用的是 Hexo 框架 + Keep 主题。"},{"title":"comment","date":"2022-01-25T16:06:46.000Z","updated":"2022-01-25T16:07:32.852Z","comments":true,"path":"comment/index.html","permalink":"https://pass1on.fun/comment/index.html","excerpt":"","text":"123&lt;h2 align=\"center\"&gt;有什么想说的?&lt;/h2&gt;&lt;h2 align=\"center\"&gt;有什么想问的?&lt;/h2&gt;"},{"title":"tags","date":"2021-12-18T02:33:54.000Z","updated":"2022-01-25T17:03:43.291Z","comments":true,"path":"tags/index.html","permalink":"https://pass1on.fun/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2022-01-25T16:07:50.000Z","updated":"2022-01-25T16:07:50.197Z","comments":true,"path":"links/index.html","permalink":"https://pass1on.fun/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 基础知识总结","slug":"Java-基础知识总结","date":"2022-03-24T09:22:34.000Z","updated":"2022-03-24T09:48:02.072Z","comments":true,"path":"2022/03/24/Java-基础知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"Java 基础知识总结","text":"Java 语言具有哪些特点？ Java 为面向对象的语言。它能够直接反应现实生活中的对象。 具有平台无关性。java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。 Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。 Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。 Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++ 难以理解的指针特性。 Java 语言提供了对 Web 应用开发的支持。 面向对象的三大特性？ 继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。 封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。 多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。 字节序定义以及Java属于哪种字节序？字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方式。 小端：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。 大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。 Java 语言的字节序是大端。 JDK与JRE有什么区别？ JDK：Java 开发工具包(Java Development Kit)，提供了 Java 的开发环境和运行环境。 JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。 JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"基础知识","slug":"基础知识","permalink":"https://pass1on.fun/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"Java-算法题解","slug":"Java-剑指offer题解","date":"2022-03-16T13:36:44.000Z","updated":"2022-03-24T09:26:29.023Z","comments":true,"path":"2022/03/16/Java-剑指offer题解/","link":"","permalink":"https://pass1on.fun/2022/03/16/Java-%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/","excerpt":"Java-Leetcode 部分算法题解","text":"数组中重复的数字在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 12345678910class Solution { public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; dic = new HashSet&lt;&gt;(); for(int num : nums) { if(dic.contains(num)) return num; dic.add(num); } return -1; }} 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 1234567891011121314151617class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int rows = matrix.length, cols = matrix[0].length; int r = 0, c = cols - 1; // 从右上角开始 while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) { if (target == matrix[r][c]) return true; else if (target &gt; matrix[r][c]) r++; else c--; } return false; }} 替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 输入：s = “We are happy.”输出：”We%20are%20happy.” 限制： 0 &lt;= s 的长度 &lt;= 10000 1234567891011class Solution { public String replaceSpace(String s) { StringBuilder res = new StringBuilder(); for(Character c : s.toCharArray()) { if(c == ' ') res.append(\"%20\"); else res.append(c); } return res.toString(); }} 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public int[] reversePrint(ListNode head) { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); while(head != null) { stack.addLast(head.val); head = head.next; } int[] res = new int[stack.size()]; for(int i = 0; i &lt; res.length; i++) res[i] = stack.removeLast(); return res; }} 连续子数组的最大和输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 &lt;= arr.length &lt;= 10^5-100 &lt;= arr[i] &lt;= 100 12345678910class Solution { public int maxSubArray(int[] nums) { int res = nums[0]; for(int i = 1; i &lt; nums.length; i++) { nums[i] += Math.max(nums[i - 1], 0); res = Math.max(res, nums[i]); } return res; }} LRU 缓存请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。实现 LRUCache 类：LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例： 输入[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4] 解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示： 1 &lt;= capacity &lt;= 30000 &lt;= key &lt;= 100000 &lt;= value &lt;= 105最多调用 2 * 105 次 get 和 put 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class LRUCache { //1.构建哈希 private Map&lt;Integer, DoubleLinkedNode&gt; cache = new HashMap&lt;&gt;(); //几个全局变量:链表大小，容量 private int size; private int capacity; //双向链表中，构造两个节点，伪头结点和伪尾节点，方便插入删除其他节点 private DoubleLinkedNode fakeHead; private DoubleLinkedNode fakeTail; //2.构建双向链表模型 class DoubleLinkedNode { //键值对 int key; int value; //前后节点 DoubleLinkedNode prev; DoubleLinkedNode next; //无参和有参构造 public DoubleLinkedNode() { } public DoubleLinkedNode(int k, int v) { this.key = k; this.value = v; } } //构造函数 public LRUCache(int capacity) { this.size = 0; this.capacity = capacity; fakeHead = new DoubleLinkedNode(); fakeTail = new DoubleLinkedNode(); fakeHead.next = fakeTail; fakeTail.prev = fakeHead; } //get方法 public int get(int key) { //1.查询哈希 DoubleLinkedNode node = cache.get(key); //为空返回-1 if (node == null) { return -1; } //2.哈希查询到，将该节点移动到头部 moveToHead(node); return node.value; } //put方法 public void put(int key, int value) { //1.哈希查询，若不存在节点，则添加 DoubleLinkedNode node = cache.get(key); if (node == null) { //创建节点，添加链表，添加哈希，增加size DoubleLinkedNode newNode = new DoubleLinkedNode(key, value); //新节点加入哈希 cache.put(key, newNode); //新节点加入头部 addToHead(newNode); ++size; //容量超出，在链表和哈希中删除尾节点 if (size &gt; capacity) { //不构造辅助方法的情况下直接删除，时间效率低// cache.remove(fakeTail.prev.key);// removeNode(fakeTail.prev); DoubleLinkedNode tail = removeTail(); cache.remove(tail.key); --size; }//若哈希中存在该节点，覆盖链表中的值，并更新该节点作为最近使用 } else { node.value = value; moveToHead(node); } } //辅助方法区： //1.将节点移动到头部 private void moveToHead(DoubleLinkedNode node) { //删除节点 removeNode(node); //头部添加该节点 addToHead(node); } //2.删除节点 private void removeNode(DoubleLinkedNode node) { node.prev.next = node.next; node.next.prev = node.prev; } //3.头部添加节点 private void addToHead(DoubleLinkedNode node) { node.prev = fakeHead; node.next = fakeHead.next; fakeHead.next.prev = node; fakeHead.next = node; } //4.删除尾节点，并返回被删除的节点 private DoubleLinkedNode removeTail(){ DoubleLinkedNode tail = fakeTail.prev; removeNode(tail); return tail; }}","categories":[{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"https://pass1on.fun/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://pass1on.fun/tags/Leetcode/"}]},{"title":"vue.js 使用 axios","slug":"vue-js-使用-axios","date":"2022-03-07T13:00:30.000Z","updated":"2022-03-07T13:20:29.692Z","comments":true,"path":"2022/03/07/vue-js-使用-axios/","link":"","permalink":"https://pass1on.fun/2022/03/07/vue-js-%E4%BD%BF%E7%94%A8-axios/","excerpt":"vue 安装使用 axios 以及 request.js 的封装","text":"安装 axiosnpm i axios -S request.js 封装12345678910111213141516171819202122232425262728293031323334353637383940414243import axios from 'axios'const request = axios.create({ baseURL: '/api', // 注意！！ 这里是全局统一加上了 '/api' 前缀，也就是说所有接口都会加上'/api'前缀在，页面里面写接口的时候就不要加 '/api'了，否则会出现2个'/api'，类似 '/api/api/user'这样的报错，切记！！！ timeout: 5000})// request 拦截器// 可以自请求发送前对请求做一些处理// 比如统一加token，对请求参数统一加密request.interceptors.request.use(config =&gt; { config.headers['Content-Type'] = 'application/json;charset=utf-8'; // config.headers['token'] = user.token; // 设置请求头 return config}, error =&gt; { return Promise.reject(error)});// response 拦截器// 可以在接口响应后统一处理结果request.interceptors.response.use( response =&gt; { let res = response.data; // 如果是返回的文件 if (response.config.responseType === 'blob') { return res } // 兼容服务端返回的字符串数据 if (typeof res === 'string') { res = res ? JSON.parse(res) : res } return res; }, error =&gt; { console.log('err' + error) // for debug return Promise.reject(error) })export default request 在 main.js 中引用 request 对象Vue.prototype.request=request","categories":[{"name":"过程记录","slug":"过程记录","permalink":"https://pass1on.fun/categories/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://pass1on.fun/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://pass1on.fun/tags/axios/"},{"name":"request.js","slug":"request-js","permalink":"https://pass1on.fun/tags/request-js/"}]},{"title":"npm 安装指定版本依赖","slug":"npm-安装指定版本依赖","date":"2022-03-07T11:15:08.000Z","updated":"2022-03-07T11:26:06.837Z","comments":true,"path":"2022/03/07/npm-安装指定版本依赖/","link":"","permalink":"https://pass1on.fun/2022/03/07/npm-%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96/","excerpt":"本文介绍 npm 安装依赖至指定版本的方法","text":"方法一先在 package.json 里修改好指定版本号，然后输入: npm update d3 方法二输入： npm update d3@5.15.0 会把 d3.js 更新至指定版本，但是不会写到 package.json 文件里，如果需要写到 package.json 里执行如下命令: npm update d3@5.15.0 --save 参考内容 淘宝镜像 npmjs 官网","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://pass1on.fun/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://pass1on.fun/tags/npm/"},{"name":"依赖","slug":"依赖","permalink":"https://pass1on.fun/tags/%E4%BE%9D%E8%B5%96/"}]},{"title":"Hexo+GithubPages-搭建博客","slug":"Hexo-GithubPages-搭建博客","date":"2021-12-31T11:59:39.000Z","updated":"2022-03-06T15:05:53.477Z","comments":true,"path":"2021/12/31/Hexo-GithubPages-搭建博客/","link":"","permalink":"https://pass1on.fun/2021/12/31/Hexo-GithubPages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"Hexo + Github Pages 简单快速搭建个人博客","text":"准备任务Github 账号注册一个 github 账号，并记住用户名与注册邮箱 Github 账号注册过程 Git 安装下载地址Git 下载 安装教程Git 安装教程 Node.js 安装下载地址Node.js 下载 安装教程Node.js 安装及环境配置教程 注意按照上述教程配置环境变量并验证是否安装成功 在命令行分别输入 1git --version 1node -v 1npm -v Typora 下载 （可选）Hexo 支持 Markdown 语法来写文章，推荐使用 Typora 作为文本编辑器 Typora 下载 Notepad++ 下载 （可选）在编辑配置文档的时候我们可以用 Notepad++ 来编辑文档 Notepad++ 下载与安装教程 创建 Github 仓库新建一个仓库 仓库名固定： 用户名.github.io 安装Hexo命令行输入 1npm install hexo-cli -g 验证安装是否成功 1hexo -v 绑定仓库进入任何一个文件夹中，在空白区域右键选择 Git Bash Here 在 git 命令行输入 ssh-keygen -t rsa -C \"注册 github 时所用邮箱\" 并敲 4 次回车 进入 C:\\Users\\你的用户名\\.ssh 文件夹 右键选中 id_rsa.pub 文件，选择使用 Notepad++ 打开 全选文件内容并复制 打开 GitHub 找到 Settings 选择 SSH and GPG keys 之后选择 New SSH key 在 Title 中输入任意内容，在 Key 中将刚才复制内容粘贴 在 git 命令行输入 ssh -T git@github.com 回答 yes 显示 Hi XXX! You've successfully...... 代表绑定成功 本地生成博客选择指定路径新建 Blog 文件夹作文博客本地仓库 在空白区域右键选择 Git Bash Here 在 git 命令行依次输入 1hexo init 1hexo g 1hexo s 打开浏览器输入 http://localhost:4000 查看效果 发布博客到互联网在刚才新建的 Blog 文件夹下，右键选择生成的 _config.yml 文件，选择使用 Notepad++ 打开 找到最后几行，将 12deploy: type: 选中删除 并在原位置输入 （注意是英文冒号，且冒号之后有空格） 1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: main 保存关闭 在 Blog 文件夹中在空白区域右键选择 Git Bash Here 在 git 命令行依次输入 1npm install hexo-deployer-git --save 1hexo g 1hexo d 验证你的 GitHub 账户 至此博客初步搭建过程结束，在浏览器输入 用户名.github.io 即可访问 参考内容 视频教程 Git 教程 Hexo 主题 Hexo 撰写文章教程 Hexo 文章加密教程 Fluid 主题","categories":[{"name":"过程记录","slug":"过程记录","permalink":"https://pass1on.fun/categories/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://pass1on.fun/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://pass1on.fun/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Python-合并多个csv文件","slug":"Python-合并多个csv文件","date":"2021-12-20T12:32:31.000Z","updated":"2022-03-06T15:06:21.908Z","comments":true,"path":"2021/12/20/Python-合并多个csv文件/","link":"","permalink":"https://pass1on.fun/2021/12/20/Python-%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcsv%E6%96%87%E4%BB%B6/","excerpt":"使用 Python 将文件夹下多个 .csv 文件合并","text":"代码123456789101112131415import globimport pandas as pdinputfile = \"文件夹路径\\*.csv\"outputfile = \"输出合并文件路径\\mergeResult.csv\"csv_list = glob.glob(inputfile)filepath = csv_list[0]df = pd.read_csv(filepath)df = df.to_csv(outputfile, index=False) #编码默认 UTF-8 ，若乱码自行更改for i in range(1, len(csv_list)): filepath = csv_list[i] df = pd.read_csv(filepath) df = df.to_csv(outputfile, index=False, header=False, mode='a+') 注意header=False 保证后续 .csv 文件是不保存列名的 参考内容Pandas 教程 Pandas 中文网","categories":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/tags/Python/"},{"name":"文件操作","slug":"文件操作","permalink":"https://pass1on.fun/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"csv","slug":"csv","permalink":"https://pass1on.fun/tags/csv/"},{"name":"Pandas","slug":"Pandas","permalink":"https://pass1on.fun/tags/Pandas/"}]},{"title":"Python-doc/docx/txt文件批量转换","slug":"Python-doc-docx-txt文件批量转换","date":"2021-12-19T06:55:21.000Z","updated":"2022-03-06T15:06:16.110Z","comments":true,"path":"2021/12/19/Python-doc-docx-txt文件批量转换/","link":"","permalink":"https://pass1on.fun/2021/12/19/Python-doc-docx-txt%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2/","excerpt":"使用 Python 实现 .doc/.docx/.txt 文件格式转换","text":"摘要 将文件夹中 doc 文件批量保存为 docx 文件 将文件夹中 docx 文件批量保存为 txt 文件 doc2docx作用python-docx 只能处理 Word2007 以后的版本 (.docx) 使用 python-docx 库读取文档前需要将 doc 文件保存为 docx 文件 代码12345678910111213141516171819202122from win32com import client as wcfrom pathlib import Pathimport osimport shutildoc_path = r\"D:\\workspace\\python\\KGProject\\syllabus\"temp_dir = \"temp\"if os.path.exists(f\"{doc_path}/{temp_dir}\"): shutil.rmtree(f\"{doc_path}/{temp_dir}\")os.mkdir(f\"{doc_path}/{temp_dir}\")word = wc.Dispatch(\"Word.Application\") try: for filename in Path(doc_path).glob(\"*.doc\"): file = str(filename) dest_name = str(filename.parent/f\"{temp_dir}\"/str(filename.name))+\"x\" print(file, dest_name) doc = word.Documents.Open(file) # 另存为后缀为 \".docx\" 的文件，其中参数 16 指 docx 文件 doc.SaveAs(dest_name, 16)finally: word.Quit() docx2txt作用将文档转换为 txt 文件方便处理纯文本数据 代码12345678910111213141516171819202122from win32com import client as wcfrom pathlib import Pathimport osimport shutildoc_path = r\"D:\\workspace\\python\\KGProject\\syllabus\"temp_dir = \"temp\"if os.path.exists(f\"{doc_path}/{temp_dir}\"): shutil.rmtree(f\"{doc_path}/{temp_dir}\")os.mkdir(f\"{doc_path}/{temp_dir}\")word = wc.Dispatch(\"Word.Application\") try: for filename in Path(doc_path).glob(\"*.docx\"): file = str(filename) dest_name = str(filename.parent/f\"{temp_dir}\"/str(filename.name[:-4]))+\"txt\" print(file, dest_name) doc = word.Documents.Open(file) # 另存为后缀为 \".txt\" 的文件，其中参数 2 指 txt 文件 doc.SaveAs(dest_name, 2)finally: word.Quit()","categories":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/tags/Python/"},{"name":"文件操作","slug":"文件操作","permalink":"https://pass1on.fun/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]}],"categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/categories/%E9%A2%98%E8%A7%A3/"},{"name":"过程记录","slug":"过程记录","permalink":"https://pass1on.fun/categories/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"name":"问题解决","slug":"问题解决","permalink":"https://pass1on.fun/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/categories/Python/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"基础知识","slug":"基础知识","permalink":"https://pass1on.fun/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"https://pass1on.fun/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://pass1on.fun/tags/Leetcode/"},{"name":"Vue","slug":"Vue","permalink":"https://pass1on.fun/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://pass1on.fun/tags/axios/"},{"name":"request.js","slug":"request-js","permalink":"https://pass1on.fun/tags/request-js/"},{"name":"npm","slug":"npm","permalink":"https://pass1on.fun/tags/npm/"},{"name":"依赖","slug":"依赖","permalink":"https://pass1on.fun/tags/%E4%BE%9D%E8%B5%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://pass1on.fun/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://pass1on.fun/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/tags/Python/"},{"name":"文件操作","slug":"文件操作","permalink":"https://pass1on.fun/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"csv","slug":"csv","permalink":"https://pass1on.fun/tags/csv/"},{"name":"Pandas","slug":"Pandas","permalink":"https://pass1on.fun/tags/Pandas/"}]}