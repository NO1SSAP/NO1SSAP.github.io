{"meta":{"title":"Passion's Blog","subtitle":"","description":"","author":"Passion","url":"https://pass1on.fun","root":"/"},"pages":[{"title":"categories","date":"2021-12-18T02:33:04.000Z","updated":"2022-01-25T17:03:30.215Z","comments":true,"path":"categories/index.html","permalink":"https://pass1on.fun/categories/index.html","excerpt":"","text":""},{"title":"comment","date":"2022-01-25T16:06:46.000Z","updated":"2022-01-25T16:07:32.852Z","comments":true,"path":"comment/index.html","permalink":"https://pass1on.fun/comment/index.html","excerpt":"","text":"123&lt;h2 align=\"center\"&gt;有什么想说的?&lt;/h2&gt;&lt;h2 align=\"center\"&gt;有什么想问的?&lt;/h2&gt;"},{"title":"about","date":"2022-01-01T00:34:55.000Z","updated":"2022-03-06T15:07:04.814Z","comments":true,"path":"about/index.html","permalink":"https://pass1on.fun/about/index.html","excerpt":"","text":"欢迎来访我的博客，本站使用的是 Hexo 框架 + Keep 主题。"},{"title":"links","date":"2022-01-25T16:07:50.000Z","updated":"2022-01-25T16:07:50.197Z","comments":true,"path":"links/index.html","permalink":"https://pass1on.fun/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-12-18T02:33:54.000Z","updated":"2022-01-25T17:03:43.291Z","comments":true,"path":"tags/index.html","permalink":"https://pass1on.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构与算法知识总结","slug":"数据结构与算法知识总结","date":"2022-03-24T14:00:52.000Z","updated":"2022-03-24T14:12:34.851Z","comments":true,"path":"2022/03/24/数据结构与算法知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"数据结构与算法知识总结","text":"简述数据结构栈栈是一种线性表，其限制只能在表尾进行插入或删除操作。由于该特性又称为后进先出的线性表。 简述数据结构队列队列是一种先进先出的线性表。其限制只能在线性表的一端进行插入，而在另一端删除元素。 简述二叉树二叉树是 n 个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。 简述满二叉树一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。 简述完全二叉树一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。 简述二叉树的前中后序遍历算法前序遍历：若二叉树为空树，则执行空逻辑，否则： 访问根节点 递归前序遍历左子树 递归前序遍历右子树 中序遍历：若二叉树为空树，则执行空逻辑，否则： 递归中序遍历左子树 访问根节点 递归中序遍历右子树 后序遍历：若二叉树为空树，则执行空逻辑，否则： 递归后序遍历左子树 递归后序遍历右子树 访问根节点 简述解决 Hash 冲突的方法开放定址法：当发生哈希冲突时，如果哈希表未被装满，那么可以把这个值存放到冲突位置中的下一个空位置中去 链地址法：对相同的哈希地址，设置一个单链表，单链表内放的都是哈希冲突元素。 简述 AVL 树AVL 树是一种改进版的搜索二叉树，其引入平衡因子（左子支高度与右子支高度之差的绝对值），通过旋转使其尽量保持平衡。 任何一个节点的左子支高度与右子支高度之差的绝对值不超过1。 简述红黑树红黑树本身是有 2-3 树发展而来，红黑树是保持黑平衡的二叉树，其查找会比 AV L树慢一点，添加和删除元素会比 AVL 树快一点。增删改查统计性能上讲，红黑树更优。 红黑树主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。红黑树和 AVL 树类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。红黑树保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 O(logn)。红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。 简述稳定排序和非稳定排序的区别稳定排序：排序前后两个相等的数相对位置不变，则算法稳定 非稳定排序：排序前后两个相等的数相对位置发生了变化，则算法不稳定 常见的稳定排序算法有哪些插入排序、冒泡排序、归并排序 常见的不稳定排序算法有哪些希尔排序、直接选择排序、堆排序、快速排序 简述插入排序插入排序：每一趟将一个待排序记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。 排序算法稳定。时间复杂度 O(n²)，空间复杂度 O(1)。 简述希尔排序希尔排序：把记录按下标的一定增量分组，对每组进行直接插入排序，每次排序后减小增量，当增量减至 1 时排序完毕。 排序算法不稳定。时间复杂度 O(nlogn)，空间复杂度 O(1)。 简述直接选择排序直接选择排序：每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余未排序序列中重复该操作直到所有元素排序完毕。 排序算法不稳定。时间复杂度 O(n²)，空间复杂度 O(1)。 简述堆排序堆排序：将待排序数组看作一个树状数组，建立一个二叉树堆。通过对这种数据结构进行每个元素的插入，完成排序工作。 排序算法不稳定，时间复杂度 O(nlogn)，空间复杂度 O(1)。 简述冒泡排序冒泡排序：比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作。 排序算法稳定，时间复杂度 O(n²)，空间复杂度 O(1)。 简述快速排序快速排序：随机选择一个基准元素，通过一趟排序将要排序的数据分割成独立的两部分，一部分全部小于等于基准元素，一部分全部大于等于基准元素，再按此方法递归对这两部分数据进行快速排序。 排序算法不稳定，时间复杂度 O(nlogn)，空间复杂度 O(logn)。 简述归并排序归并排序：将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并。 排序算法稳定，时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。 简述图图是由顶点集合和顶点之间的边集合组成的一种数据结构，分为有向图和无向图。 有向图：边具有方向性 无向图：边不具有方向性 简述邻接矩阵用一个二维数组存放图顶点间关系的数据，这个二维数组称为邻接矩阵。 对于无向图，邻接矩阵是对称矩阵 简述邻接表邻接表是通过链表表示图连接关系的一种方。对于表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。 简述图的深度优先搜索 DFS将图中每个顶点的访问标志设为 FALSE, 之后搜索图中每个顶点，如果未被访问，则以该顶点 V0 为起始点出发，访问此顶点，然后依次从 V0 的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 V0 有路径相通的顶点都被访问到。 简述图的广度优先搜索从图中的某个顶点 V0 出发，并在访问此顶点之后依次访问 V0 的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和 V0 有路径相通的顶点都被访问到。 简述最小生成树和其对应的算法对于有 n 个结点的原图，生成原图的极小连通子图，其包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 普里姆算法：取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n-1 个顶点为止。 克鲁斯卡尔算法：先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使 SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n-1 条边为止。 简述最短路径算法Dijkstral 算法为求解一个点到其余各点最小路径的方法，其算法为： 假设我们求解的是顶点 v 到其余各个点的最短距离。n 次循环至 n 个顶点全部遍历： 从权值数组中找到权值最小的，标记该边端点 k 打印该路径及权值 如果存在经过顶点k到顶点i的边比v-&gt;i的权值小 更新权值数组及对应路径 简述堆堆是一种完全二叉树形式，其可分为最大值堆和最小值堆。 最大值堆：子节点均小于父节点，根节点是树中最大的节点。 最小值堆：子节点均大于父节点，根节点是树中最小的节点。 简述 setSet 是一种集合。集合中的对象不按特定的方式排序，并且没有重复对象。 说一下对于树的理解数据结构树是一种由有限节点组成的层次关系的集合。其特点如下： 每个节点有零个或多个子节点； 只有一个节点没有父节点，该节点称为根节点； 除根节点外，每个节点有且只有一个父节点； 简述二叉查找树 二叉查找树的左子树若不为空，则左子树上所有结点的值均小于它的根结点的值； 二叉查找树的右子树若不为空，则右子树上所有结点的值均大于它的根结点的值； 二叉查找树的左、右子树也分别为二叉查找树； 没有键值相等的结点。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://pass1on.fun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"设计模式知识总结","slug":"设计模式知识总结","date":"2022-03-24T13:54:53.000Z","updated":"2022-03-24T14:00:11.968Z","comments":true,"path":"2022/03/24/设计模式知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"设计模式知识总结","text":"简述设计模式七大原则开放封闭原则：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 单一职责原则：一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。 依赖倒置原则：针对接口编程，依赖于抽象类或接口而不依赖于具体实现类。 接口隔离原则：将不同功能定义在不同接口中实现接口隔离。 里氏替换原则：任何基类可以出现的地方，子类一定可以出现。 迪米特原则：每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。 合成复用原则：尽量使用组合(has-a)/聚合(contains-a)而不是继承(is-a)达到软件复用的目的。 简述设计模式的分类创建型模式：在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 简述简单工厂模式简单工厂模式指由一个工厂对象来创建实例,适用于工厂类负责创建对象较少的情况。例子：Spring 中的 BeanFactory 使用简单工厂模式，产生 Bean 对象。 简述工厂模式工厂方法模式指定义一个创建对象的接口，让接口的实现类决定创建哪种对象，让类的实例化推迟到子类中进行。例子：Spring 的 FactoryBean 接口的 getObject 方法也是工厂方法。 简述抽象工厂模式抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。例子：java.sql.Connection 接口。 简述单例模式一个单例类在任何情况下都只存在一个实例。 饿汉式实现 123456789public class Singleton { private Singleton(){} private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; }} 懒汉式实现 12345678910111213141516public class Singleton { private DoubleCheckSingleton(){} private volatile static Singleton instance; public static Singleton getInstance() { if(instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 简述代理模式代理模式为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在客户端和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度。 静态代理：在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 动态代理：程序运行期间动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。 简述适配器模式适配器模式将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。 简述模板模式模板模式定义了一个操作中的算法的骨架，并将一些步骤延迟到子类，适用于抽取子类重复代码到公共父类。 可以封装固定不变的部分，扩展可变的部分。但每一个不同实现都需要一个子类维护，会增加类的数量。 简述装饰器模式装饰者模式可以动态地给对象添加一些额外的属性或行为，即需要修改原有的功能，但又不愿直接去修改原有的代码时，设计一个 Decorator 套在原有代码外面。 简述观察者模式观察者模式表示的是一种对象与对象之间具有依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"设计模式","slug":"设计模式","permalink":"https://pass1on.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Redis 知识总结","slug":"Redis-知识总结","date":"2022-03-24T13:41:06.000Z","updated":"2022-03-24T13:54:09.571Z","comments":true,"path":"2022/03/24/Redis-知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/Redis-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"Redis 知识总结","text":"Redis 单线程原理首先必须明确，Redis 单线程指的是网络请求模块使用了一个线程（，其他模块仍用了多个线程。并不是一个线程完成了所有功能。 原理上，其采用了利用 epoll 的多路复用特性，因此可以采用单线程处理其网络请求。 Redis 数据类型String：字符串类型，最简单的类型 Hash：类似于 Map 的一种结构 List：有序列表 Set：无序集合 ZSet：带权值的无序集合，即每个 ZSet 元素还另有一个数字代表权值，集合通过权值进行排序。 什么情况下使用 redis 针对热点数据进行缓存 对于特定限时数据的存放 针对带热点权值数据的排序list 分布式锁 redis 与 memcache 的区别 redis 处理网络请求采用单线程模型，而 memcache 采用多线程异步 IO 的方式 redis 支持数据持久化，memcache 不支持 redis 支持的数据格式比 memcache 更多 简述缓存穿透缓存穿透指缓存和数据库均没有需要查询的数据，攻击者不断发送这种请求，使数据库压力过大。 简述缓存穿透的解决方法 在数据库操作访问前进行校验，对不合法请求直接返回。 对于经常被访问的，并且数据库没有的键，缓存层记录键 =null。 简述缓存击穿缓存击穿指缓存中没有数据，但数据库中有该数据。一般这种情况指特定数据的缓存时间到期，但由于并发用户访问该数据特别多，因此去数据库去取数据，引起数据库访问压力过大 简述缓存击穿的解决方法 设置热点数据永远不过期。 对并发读数据设置并发锁，降低并发性 简述缓存雪崩缓存雪崩指缓存中一大批数据到过期时间，而从缓存中删除。但该批数据查询数据量巨大，查询全部走数据库，造成数据库压力过大。 简述缓存雪崩的解决方法 缓存数据设置随机过期时间，防止同一时间大量数据过期。 设置热点数据永远不过期。 对于集群部署的情况，将热点数据均与分布在不同缓存中。 Redis 有哪些集群部署方式 主从复制 哨兵模式 Cluster 集群模式 简述主从复制模式在主从复制中，有主库（Master）节点和从库（Slave）节点两个角色。 从节点服务启动会连接主库，并向主库发送 SYNC 命令。 主节点收到同步命令，启动持久化工作，工作执行完成后，主节点将传送整个数据库文件到从库，从节点接收到数据库文件数据之后将数据进行加载。此后，主节点继续将所有已经收集到的修改命令，和新的修改命令依次传送给从节点，从节点依次执行，从而达到最终的数据同步。 通过这种方式，可以使写操作作用于主库，而读操作作用于从库，从而达到读写分离。 简述哨兵模式哨兵模式监控 redis集群中 Master 的工作的状态。在 Master 主服务器宕机时，从 slave 中选择新机器当作 master，保证系统高可用。 每个哨兵每 10 秒向主服务器，slave 和其他哨兵发送 ping。 客户端通过哨兵，由哨兵提供可供服务的 redis master 节点。 哨兵只需要配 master 节点，会自动寻找其对应的 slave 节点。 监控同一 master 节点的哨兵会自动互联，组成哨兵网络，当任一哨兵发现 master 连接不上，即开会投票，投票半数以上决定 Master 下线，并从 slave 节点中选取 master 节点。 cluster 集群cluster 提出了虚拟槽的概念。 redis cluster 默认有 16384 个槽，在集群搭建的时候，需要给节点分配哈希槽尽可能相同数量虚拟槽。 如果目前 redis 执行 set 操作，redis 先对这个 key 经过 CRC16 hash 运算，并把结果对 16384 取余，得到槽编号。 根据槽编号，寻找到其对应的 redis 节点，在节点上执行 hash 命令。 如果此时执行 get 操作，节点先验证该 key 对应的槽编号是不是归本节点管，如果是则保存数据。如果不是，则发送正确节点编号给客户端。 简述 Redis 的 RDBRDB 即将当前数据生成快照，并保存于硬盘中。可以通过手动命令，也可以设置自动触发。 简述 Redis 的 save 命令save 命令是 redis 手动触发 RDB 过程的命令。使用该命令后，服务器阻塞，直到 RDB 过程完成后终止。该过程占用内存较多。 简述 Redis 的 bgsave 命令bgsave 命令不阻塞主进程（严格意义上也不是完全不阻塞，详看下面过程），该命令 fork 一个子进程用于执行 RDB 过程。其具体过程为： 判断此时有没有子进程用于 RDB，有的话直接返回。 redis 进行 fork 子进程过程，此时父进程处于阻塞状态。 子进程创建 RDB 文件，完成后返回给父进程 简述 Redis 自动触发 RDB 机制 通过配置文件，设置一定时间后自动执行 RDB 如采用主从复制过程，会自动执行 RDB Redis 执行 shutdown 时，在未开启 AOF 后会执行 RDB 简述 Redis 的 AOFAOF 通过日志，对数据的写入修改操作进行记录。这种持久化方式实时性更好。通过配置文件打开 AOF。 简述 AOF 的持久化策略 always。每执行一次数据修改命令就将其命令写入到磁盘日志文件上。 everysec。每秒将命令写入到磁盘日志文件上。 no。不主动设置，由操作系统决定什么时候写入到磁盘日志文件上。 RDB 与 AOF 优缺点比较AOF 占用的文件体积比 RDB 大。一般来说利用 AOF 备份对系统的消耗比 RDB 低。对于备份时出现系统故障，RDB 数据可能会全丢，但AOF 只会损失一部分。 RDB 恢复速度比 AOF 低。 简述 Redis 淘汰机制 noeviction：默认禁止驱逐数据。内存不够使用时，对申请内存的命令报错。 volatile-lru：从设置了过期时间的数据集中淘汰最近没使用的数据。 volatile-ttl：从设置了过期时间的数据集中淘汰即将要过期的数据。 volatile-random：从设置了过期时间的数据中随机淘汰数据。 allkeys-lru：淘汰最近没使用的数据。 allkeys-random：随机淘汰数据。 MySQL 与 Redis 区别mysql 是关系型数据库，并且其将数据存储在硬盘中，读取速度较慢。 redis 是非关系型数据库，并且其将数据存储在内存中，读取速度较快。 简述 Redis 过期策略 定期删除，redis 默认是每 100ms 就随机抽取一些设置了过期时间的 key，并检查其是否过期，如果过期就删除。因此该删除策略并不会删除所有的过期 key。 惰性删除，在客户端需要获取某个 key 时，redis 将首先进行检查，若该 key 设置了过期时间并已经过期就会删除。 实际上 redis 结合上述两种手段结合起来，保证删除过期的 key。 Redis 基本数据类型实现原理字符串：采用类似数组的形式存储 list：采用双向链表进行具体实现 hash：采用 hashtable 或者 ziplist 进行具体实现 集合：采用 intset 或 hashtable 存储 有序集合：采用 ziplist 或 skiplist+hashtable 实现 Redis 快的原因 redis 是基于内存的数据库，内存数据读取存储效率远高于硬盘型 redis 采用多路复用技术通过采用 epoll 的非阻塞 IO，提升了效率","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"Redis","slug":"Redis","permalink":"https://pass1on.fun/tags/Redis/"}]},{"title":"数据库知识总结","slug":"数据库知识总结","date":"2022-03-24T13:02:29.000Z","updated":"2022-03-24T13:40:32.056Z","comments":true,"path":"2022/03/24/数据库知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"数据库知识总结","text":"简述数据库三大范式第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。 数据库第二范式：关系模式必须满足第一范式，并且所有非主属性都完全依赖于主码。注意，符合第二范式的关系模型可能还存在数据冗余、更新异常等问题。关系模型（学号，姓名，专业编号，专业名称）中，学号-&gt;姓名，而专业编号-&gt;专业名称，不满足数据库第二范式 数据库第三范式：关系模型满足第二范式，所有非主属性对任何候选关键字都不存在传递依赖。即每个属性都跟主键有直接关系而不是间接关系。接着以学生表举例，对于关系模型（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）院校地址，院校电话和学号不存在直接关系，因此不满足第三范式。 简述 MySQL 的架构MySQL可以分为应用层,逻辑层,数据库引擎层,物理层。 应用层：负责和客户端，响应客户端请求，建立连接，返回数据。 逻辑层：包括 SQK 接口，解析器，优化器，Cache 与 buffer。 数据库引擎层：有常见的 MyISAM,InnoDB 等等。 物理层：负责文件存储，日志等等。 简述执行 SQL 语言的过程 客户端首先通过连接器进行身份认证和权限相关 如果是执行查询语句的时候，会先查询缓存，但 MySQL 8.0 版本后该步骤移除。 没有命中缓存的话，SQL 语句就会经过解析器，分析语句，包括语法检查等等。 通过优化器，将用户的 SQL 语句按照 MySQL 认为最优的方案去执行。 执行语句，并从存储引擎返回数据。 简述 MySQL 的共享锁排它锁共享锁也称为读锁，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。排他锁也称为写锁，会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。 简述 MySQL 中的按粒度的锁分类表级锁: 对当前操作的整张表加锁,实现简单，加锁快，但并发能力低。 行锁: 锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么 InnoDB 会创建一个隐藏的聚簇索引加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 Gap 锁：也称为间隙锁: 锁定一个范围但不包括记录本身。其目的是为了防止同一事物的两次当前读出现幻读的情况。 Next-key Lock： 行锁+gap锁。 如何解决数据库死锁 预先检测到死锁的循环依赖，并立即返回一个错误。 当查询的时间达到锁等待超时的设定后放弃锁请求。 简述乐观锁和悲观锁乐观锁：对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁，只有到数据提交的时候才通过一种机制来验证数据是否存在冲突。 悲观锁：对于数据冲突保持一种悲观态度，在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的。 简述 InnoDB 存储引擎InnoDB 是 MySQL 的默认事务型引擎，支持事务，表是基于聚簇索引建立的。支持表级锁和行级锁，支持外键，适合数据增删改查都频繁的情况。 InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 REPEATABLE READ，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。 简述 MyISAM 存储引擎MySQL5.1及之前，MyISAM 是默认存储引擎。MyISAM 不支持事务，Myisam 支持表级锁，不支持行级锁，表不支持外键，该存储引擎存有表的行数，count运算会更快。适合查询频繁，不适合对于增删改要求高的情况 简述 Memory 存储引擎Memory 存储引擎将所有数据都保存在内存，不需要磁盘 IO。支持哈希索引，因此查找速度极快。Memory 表使用表级锁，因此并发写入的性能较低。 索引是什么？索引是存储引擎中用于快速找到记录的一种数据结构。在关系型数据库中，索引具体是一种对数据库中一列或多列的值进行排序的存储结构。 为什么引入索引？为了提高数据查询的效率。索引对数据库查询良好的性能非常关键，当表中数据量越来越大，索引对性能的影响越重要。 Mysql 有哪些常见索引类型？ 数据结构角度 B-Tree索引 哈希索引 R-Tree索引 全文索引 物理存储角度 主键索引（聚簇索引）：叶子节点存的是整行的数据 非主键索引（二级索引）：叶子节点存的主键的值 简述 B-Tree 与 B+ 树B-Tree 是一种自平衡的多叉树。每个节点都存储关键字值。其左子节点的关键字值小于该节点关键字值，且右子节点的关键字值大于或等于该节点关键字值。 B+ 树也是是一种自平衡的多叉树。其基本定义与 B 树相同，不同点在于数据只出现在叶子节点，所有叶子节点增加了一个链指针，方便进行范围查询。 B+ 树中间节点不存放数据，所以同样大小的磁盘页上可以容纳更多节点元素，访问叶子节点上关联的数据也具有更好的缓存命中率。并且数据顺序排列并且相连，所以便于区间查找和搜索。 B 树每一个节点都包含 key 和 value，查询效率比 B+ 树高。 简述 Hash 索引哈希索引对于每一行数据计算一个哈希码，并将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。只有 Memory 引擎显式支持哈希索引。 Hash索引不支持范围查询，无法用于排序，也不支持部分索引列匹配查找。 简述自适应 Hash 索引InnoDB 对于频繁使用的某些索引值，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这也被称为自适应 Hash 索引。 简述聚集索引和稀疏索引聚集索引按每张表的主键构建一棵 B+ 树，数据库中的每个搜索键值都有一个索引记录，每个数据页通过双向链表连接。表数据访问更快，但表更新代价高。 稀疏索引不会为每个搜索关键字创建索引记录。搜索过程需要，我们首先按索引记录进行操作，并按顺序搜索，直到找到所需的数据为止。 简述辅助索引与回表查询辅助索引是非聚集索引，叶子节点不包含记录的全部数据，包含了一个书签用来告诉 InnoDB 哪里可以找到与索引相对应的行数据。 通过辅助索引查询，先通过书签查到聚集索引，再根据聚集索引查对应的值，需要两次，也称为回表查询。 简述联合索引和最左匹配原则联合索引是指对表上的多个列的关键词进行索引。 对于联合索引的查询，如果精确匹配联合索引的左边连续一列或者多列，则 mysql 会一直向右匹配直到遇到范围查询（&gt;,&lt;,between,like）就停止匹配。Mysql 会对第一个索引字段数据进行排序，在第一个字段基础上，再对第二个字段排序。 简述覆盖索引覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不需要回表查询，即索引本身存了对应的值。 为什么数据库不用红黑树用 B+ 树红黑树的出度为 2，而 B Tree 的出度一般都非常大。红黑树的树高 h 很明显比 B Tree 大非常多，IO 次数很多，导致会比较慢，因此检索的次数也就更多。 B+Tree 相比于 B-Tree 更适合外存索引，拥有更大的出度，IO 次数较少，检索效率会更高。 基于主键索引的查询和非主键索引的查询有什么区别？对于select * from 主键=XX，基于主键的普通查询仅查找主键这棵树，对于 select * from 非主键=XX，基于非主键的查询有可能存在回表过程（回到主键索引树搜索的过程称为回表），因为非主键索引叶子节点仅存主键值，无整行全部信息。 非主键索引的查询一定会回表吗？不一定，当查询语句的要求字段全部命中索引，不用回表查询。如 select 主键 from 非主键=XX，此时非主键索引叶子节点即可拿到主键信息，不用回表。 简述 MySQL 使用 EXPLAIN 的关键字段explain 关键字用于分析 sql 语句的执行情况，可以通过他进行 sql 语句的性能分析。 type：表示连接类型，从好到差的类型排序为 system：系统表，数据已经加载到内存里。 const：常量连接，通过索引一次就找到。 eq_ref：唯一性索引扫描，返回所有匹配某个单独值的行。 ref：非主键非唯一索引等值扫描，const或eq_ref改为普通非唯一索引。 range：范围扫描，在索引上扫码特定范围内的值。 index：索引树扫描，扫描索引上的全部数据。 all：全表扫描。 key：显示 MySQL 实际决定使用的键。 key_len：显示 MySQL 决定使用的键长度，长度越短越好 Extra：额外信息 Using filesort：MySQL 使用外部的索引排序，很慢需要优化。 Using temporary：使用了临时表保存中间结果，很慢需要优化。 Using index：使用了覆盖索引。 Using where：使用了 where。 简述 MySQL 优化流程 通过慢日志定位执行较慢的 SQL 语句 利用 explain 对这些关键字段进行分析 根据分析结果进行优化 简述 MySQL 中的日志 logredo log：存储引擎级别的 log（InnoDB 有，MyISAM 没有），该 log 关注于事务的恢复.在重启 mysql 服务的时候，根据 redo log 进行重做，从而使事务有持久性。 undo log：是存储引擎级别的 log（InnoDB 有，MyISAM 没有）保证数据的原子性，该 log 保存了事务发生之前的数据的一个版本，可以用于回滚，是 MVCC 的重要实现方法之一。 bin log：数据库级别的 log，关注恢复数据库的数据。 简述事务事务内的语句要么全部执行成功，要么全部执行失败。 事务满足如下几个特性： 原子性（Atomicity）一个事务中的所有操作要么全部完成，要么全部不完成。 一致性（Consistency） 事务执行前后数据库的状态保存一致。 隔离性（Isolation） 多个并发事务对数据库进行操作，事务间互不干扰。 持久性（Durability） 事务执行完毕，对数据的修改是永久的，即使系统故障也不会丢失 数据库中多个事务同时进行可能会出现什么问题？ 丢失修改 脏读：当前事务可以查看到别的事务未提交的数据。 不可重读：在同一事务中，使用相同的查询语句，同一数据资源莫名改变了。 幻读：在同一事务中，使用相同的查询语句，莫名多出了一些之前不存在的数据，或莫名少了一些原先存在的数据。 SQL 的事务隔离级别有哪些？ 读未提交：一个事务还没提交，它做的变更就能被别的事务看到。 读提交： 一个事务提交后，它做的变更才能被别的事务看到。 可重复读： 一个事务执行过程中看到的数据总是和事务启动时看到的数据是一致的。在这个级别下事务未提交，做出的变更其它事务也看不到。 串行化： 对于同一行记录进行读写会分别加读写锁，当发生读写锁冲突，后面执行的事务需等前面执行的事务完成才能继续执行。 什么是 MVCC？MVCC 为多版本并发控制，即同一条记录在系统中存在多个版本。其存在目的是在保证数据一致性的前提下提供一种高并发的访问性能。对数据读写在不加读写锁的情况下实现互不干扰,从而实现数据库的隔离性,在事务隔离级别为读提交和可重复读中使用到。 在 InnoDB 中，事务在开始前会向事务系统申请一个事务 ID，该 ID 是按申请顺序严格递增的。每行数据具有多个版本，每次事务更新数据都会生成新的数据版本，而不会直接覆盖旧的数据版本。数据的行结构中包含多个信息字段。其中实现 MVCC 的主要涉及最近更改该行数据的事务ID（DBTRXID）和可以找到历史数据版本的指针（DBROLLPTR）。InnoDB 在每个事务开启瞬间会为其构造一个记录当前已经开启但未提交的事务 ID 的视图数组。通过比较链表中的事务 ID 与该行数据的值与对应的 DBTRXID，并通过 DBROLLPTR 找到历史数据的值以及对应的 DBTRXID 来决定当前版本的数据是否应该被当前事务所见。最终实现在不加锁的情况下保证数据的一致性。 读提交和可重复读都基于 MVCC 实现，有什么区别？在可重复读级别下，只会在事务开始前创建视图，事务中后续的查询共用一个视图。而读提交级别下每个语句执行前都会创建新的视图。因此对于可重复读，查询只能看到事务创建前就已经提交的数据。而对于读提交，查询能看到每个语句启动前已经提交的数据。 InnoDB 如何保证事务的原子性、持久性和一致性？利用 undo log 保障原子性。该 log 保存了事务发生之前的数据的一个版本，可以用于回滚，从而保证事务原子性。 利用 redo log 保证事务的持久性，该 log 关注于事务的恢复.在重启 mysql 服务的时候，根据 redo log 进行重做，从而使事务有持久性。 利用 undo log+redo log 保障一致性。事务中的执行需要 redo log，如果执行失败，需要 undo log 回滚。 MySQL 是如何保证主备一致的？MySQL 通过 binlog（二进制日志）实现主备一致。binlog 记录了所有修改了数据库或可能修改数据库的语句，而不会记录 select、show这种不会修改数据库的语句。在备份的过程中，主库 A 会有一个专门的线程将主库 A 的 binlog 发送给备库 B 进行备份。其中 binlog 有三种记录格式： statement:记录对数据库进行修改的语句本身，有可能会记录一些额外的相关信息。优点是 binlog 日志量少，IO 压力小，性能较高。缺点是由于记录的信息相对较少，在不同库执行时由于上下文的环境不同可能导致主备不一致。 row:记录对数据库做出修改的语句所影响到的数据行以及对这些行的修改。比如当修改涉及多行数据，会把涉及的每行数据都记录到 binlog。优点是能够完全的还原或者复制日志被记录时的操作。缺点是日志量占用空间较大，IO 压力大，性能消耗较大。 mixed:混合使用上述两种模式，一般的语句使用 statment 方式进行保存，如果遇到一些特殊的函数，则使用 row 模式进行记录。 MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式， 否则就用 statement 格式。但是在生产环境中，一般会使用 row 模式。 redo log 与 binlog 的区别？ redo log 是 InnoDB 引擎特有的，只记录该引擎中表的修改记录。binlog 是 MySQL 的 Server 层实现的，会记录所有引擎对数据库的修改。 redo log 是物理日志，记录的是在具体某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑。 redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的，binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。 crash-safe 能力是什么？InnoDB 通过 redo log 保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。 WAL 技术是什么？WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。事务在提交写入磁盘前，会先写到 redo log 里面去。如果直接写入磁盘涉及磁盘的随机 I/O 访问，涉及磁盘随机 I/O 访问是非常消耗时间的一个过程，相比之下先写入 redo log，后面再找合适的时机批量刷盘能提升性能。 两阶段提交是什么？为了保证 binlog 和 redo log 两份日志的逻辑一致，最终保证恢复到主备数据库的数据是一致的，采用两阶段提交的机制。 执行器调用存储引擎接口，存储引擎将修改更新到内存中后，将修改操作记录 redo log 中，此时 redo log 处于 prepare 状态。 存储引擎告知执行器执行完毕，执行器生成这个操作对应的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交 commit 状态，更新完成。 只靠 binlog 可以支持数据库崩溃恢复吗？不可以。 历史原因： InnoDB 在作为 MySQL 的插件加入 MySQL 引擎家族之前，就已经是一个提供了崩溃恢复和事务支持的引擎了。InnoDB 接入了 MySQL 后，发现既然 binlog 没有崩溃恢复的能力，那引入 InnoDB 原有的 redo log 来保证崩溃恢复能力。 实现原因： binlog 没有记录数据页修改的详细信息，不具备恢复数据页的能力。binlog 记录着数据行的增删改，但是不记录事务对数据页的改动，这样细致的改动只记录在 redo log 中。当一个事务做增删改时，其实涉及到的数据页改动非常细致和复杂，包括行的字段改动以及行头部以及数据页头部的改动，甚至 b+tree 会因为插入一行而发生若干次页面分裂，那么事务也会把所有这些改动记录下来到 redo log 中。因为数据库系统进程 crash 时刻，磁盘上面页面镜像可以非常混乱，其中有些页面含有一些正在运行着的事务的改动，而一些已提交的事务的改动并没有刷上磁盘。事务恢复过程可以理解为是要把没有提交的事务的页面改动都去掉，并把已经提交的事务的页面改动都加上去这样一个过程。这些信息，都是 binlog 中没有记录的，只记录在了存储引擎的 redo log 中。 操作写入 binlog 可细分为 write 和 fsync 两个过程，write 指的就是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘,fsync 才是将数据持久化到磁盘的操作。通过参数设置 sync_binlog 为 0 的时候，表示每次提交事务都只 write，不 fsync。此时数据库崩溃可能导致部分提交的事务以及 binlog 日志由于没有持久化而丢失。 简述 MySQL 主从复制MySQL 提供主从复制功能，可以方便的实现数据的多处自动备份，不仅能增加数据库的安全性，还能进行读写分离，提升数据库负载性能。 主从复制流程： 在事务完成之前，主库在 binlog 上记录这些改变，完成 binlog 写入过程后，主库通知存储引擎提交事物 从库将主库的 binlog 复制到对应的中继日志，即开辟一个 I/O 工作线程，I/O 线程在主库上打开一个普通的连接，然后开始 binlog dump process，将这些事件写入中继日志。从主库的 binlog 中读取事件，如果已经读到最新了，线程进入睡眠并等待 ma 主库产生新的事件。 读写分离：即只在 MySQL 主库上写，只在 MySQL 从库上读，以减少数据库压力，提高性能。 MySQL 数据存储过程一般来说，普通的 SQL 语句需要先编译然后执行，而存储过程可以理解为为了完成特定功能的已经编译后的 SQL 语句集。用户可通过存储过程的名字并给定参数来调用。 MySQL 数据库触发器触发器简单来说就是监视某种情况，并触发某种操作。 当触发器所在表上出现指定事件(insert/update/delete)时，可指定时间(after/before)执行特定事件(insert/update/delete)。 SQL 优化方法核心就是避免全表扫描，多走索引。列举常用的一些优化方法： 尽量对利用字段较多的建立索引，即在 where 及 order by 涉及的列上建立索引。 尽量避免在 where 子句中使用 or ，null值判断，in 和对字段进行表达式操作 建立索引时需要多考虑最左匹配原则 mysql 的操作 增删改查增：INSERT INTO 表名（字段名1，字段名2，…）VALUES（值1，值2，…） 删：DELETE FROM 表名 [WHERE 条件表达式] ​ TRUNCTE [TABLE ] 表名（删除整张表数据） 改：UPDATE 表名 SET 字段名1=值1，[ ，字段名2=值2，…] [ WHERE 条件表达式 ] 查：SELECT 字段名1，字段名2，… FROM 表名 [ WHERE 条件表达式 ] mysql 的查询语法顺序where、group by、having、order by、limit delete 和 truncate 区别delete是数据操纵语言（DML），其按行删除，支持 where 语句，执行操作采用行锁，执行操作时会将该操作记录在 redo 和 undo 中，因此支持回滚。 truncate是数据定义语言（DDL），其操作隐式提交，不支持回滚，不支持 where，删除时采用表级锁进行删除。 什么情况下分表合适针对存储了百万级乃至千万级条记录的大表。数据库在查询和插入的时候耗时太长，可通过分表，将大表拆分成小表，提升数据库性能。 关系型数据库与非关系型数据库区别关系型数据库采用了关系模型（可以简单理解为二维表格类型）组织数据，一般可以遵守事务的 ACID 特性 不是由关系模型进行存储的均可视作非关系型数据库，比如以键值对的 redis，图数据库等。 乐观锁如何保证一致性乐观锁保持一致性主要通过两个方法。 通过数据属性中，增加版本号属性，进行比较，比较目前操作数据是否是最新版本。 CAS（compare and swap）即在对数据修改过程中，采用 CAS 算法，保证在并发下的一致性。 mysql 为什么要用自增 id 作为主键直接原因是其存储机制。MySQL 采用数据页进行数据存储。 如果采用自增主键，在原先数据页写满的情况下，MySQL 对于新数据，直接开辟新页进行写操作。 如果不采用自增主键，为保障索引有序，新数据需插入到合适位置上，由此针对页数据满的情况下，MySQL 需要申请新页，并将一部分之前的页数据挪到新页上，保证按索引有序存储，相对自增主键 IO 开销更大。 大数据量的分页查询怎么优化定位对应索引 id 所处的偏移位置，之后进行查询。 1select * from table where num = 8 limit 100000,1; 变为 123select * from table where num = 8 and id &gt;= ( select id from table where num = 8 limit 100000,1) limit 100; 由于 id 走了索引，因此速度会有一定提升。 分库分表怎么做对于分库，即将一个数据库拆分为多个库。 可以通过水平拆分，或者垂直拆分的方式，将表进行拆分。 一般可以采用中间件 Sharding-JDBC 进行分库分表。 char 和 varchar 区别CHAR 的长度是不可变的，而 VARCHAR 的长度是可变的。 因此 CHAR 效率高，VARCHAR 效率偏低。 脏读是什么，如何解决一个事务读取了另一个事务修改但未提交的数据 将事务隔离级别设置为：读已提交，串行化，可重复读进行解决。 不可重复读是什么，如何解决一个事务连续读两次数据，但结果不一样。(两次读之间，数据被其他事务修改)。 将事务隔离级别设置为：串行化，可重复读进行解决。 幻读是什么，如何解决一个事务连续读两次数据，读取数据量不一样。(两次读之前，数据被其他事务删除或新增)。 将事务隔离级别设置为：串行化，或在 innodb 引擎中有 gap 锁的情况下设置可重复读进行解决。 丢失修改是什么数据被两个事务连续修改，导致第一个事务的修改被第二个事务覆盖丢失。 简述主键索引和唯一索引主键是能够唯一标识表中某一行的属性或属性组。对于表创建时未指定唯一索引的情况下，数据库会自动生成某一隐藏字段，作为唯一索引。 唯一索引是在表上一个或者多个字段组合建立的索引。 什么时候需要创建索引 需要频繁被作为查询条件的字段 查询过程中排序的字段创建索引 查询过程中统计或者分组的字段 何时索引会失效 复合索引不满足最左匹配原则 查询条件有 or where 查询语句对索引列有数学运算或函数 Mysql varchar 字段怎么存储varchar 字段开头包含一个变长字段的实际长度，后面存储的是真实字符。 B+ 树的双向有序链表有什么用可以更方便利于范围查询 简述分布式 id 生成方法snowflake 算法：利用时间戳，机器 id，当前数据库自增 id 进行拼接，生成的新的分布式 id。 undo log 如何保证原子性在执行数据操作之前，首先将原始数据备份，这就是 undo log。之后执行数据修正。 如果执行出现了错误，系统可利用 undo log 中的备份将数据恢复到事务开始之前的状态，保证事务原子性。 InnoDB 可重复读是否存在幻读问题不存在，InnoDB 通过引入间隙锁+行锁（next key lock）的方式，解决了幻读问题","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"数据库","slug":"数据库","permalink":"https://pass1on.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"操作系统知识总结","slug":"操作系统知识总结","date":"2022-03-24T12:10:07.000Z","updated":"2022-03-24T13:00:17.013Z","comments":true,"path":"2022/03/24/操作系统知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"操作系统知识总结","text":"什么是操作系统？请简要概述一下操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。 向上对用户程序提供接口，向下接管硬件资源。 操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。 操作系统有哪些分类？操作系统常规可分为批处理操作系统、分时操作系统、实时操作系统。 若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。 常见的通用操作系统有：Windows、Linux、MacOS 等。 什么是内核态和用户态？为了避免操作系统和关键数据被用户程序破坏，将处理器的执行状态分为内核态和用户态。 内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。 用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。 用户程序运行在用户态,操作系统内核运行在内核态。 如何实现内核态和用户态的切换？处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。 异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。 外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。 并发和并行的区别 并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核 cpu 上的多任务。但是从微观上看两个程序的指令是交织着运行的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。 并行（parallelism）：指严格物理意义上的同时运行，比如多核 cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的 cpu 都是往多核方面发展。 什么是进程？进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。 上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程一般由以下的部分组成： 进程控制块 PCB，是进程存在的唯一标志，包含进程标识符 PID，进程当前状态，程序和数据地址，进程优先级、CPU 现场保护区（用于进程切换），占有的资源清单等。 程序段 数据段 进程的基本操作以 Unix 系统举例： 进程的创建：fork()。新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的(但是独立的)一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。fork 函数是有趣的（也常常令人迷惑）， 因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的 PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。 1pid_t fork(void); 回收子进程：当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。 1pid_t waitpid(pid_t pid, int *statusp, int options); 加载并运行程序：execve 函数在当前进程的上下文中加载并运行一个新程序。 1int execve(const char *filename, const char *argv[], const char *envp[]); 进程终止： 1void exit(int status); 简述进程间通信方法每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程 A 把数据从用户空间拷到内核缓冲区,进程 B 再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。 不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。 进程间通信主要包括管道、系统 IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字 socket。 进程如何通过管道进行通信管道是一种最基本的 IPC 机制，作用于有血缘关系的进程之间，完成数据传递。调用 pipe 系统函数即可创建一个管道。有如下特质： 其本质是一个伪文件(实为内核缓冲区) 由两个文件描述符引用，一个表示读端，一个表示写端。 规定数据从管道的写端流入管道，从读端流出。 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区实现。 管道的局限性： 数据自己读不能自己写。 数据一旦被读走，便不在管道中存在，不可反复读取。 由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。 只能在有公共祖先的进程间使用管道。 进程如何通过共享内存通信？它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。 特点： 共享内存是最快的一种 IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。 因为多个进程可以同时操作，所以需要进行同步处理。 信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。 什么是信号一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的 30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。 发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因： 内核检测到一个系统事件，比如除零错误或者子进程终止。 —个进程调用了 kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。 如何编写正确且安全的信号处理函数 处理程序要尽可能简单。 避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查(并重置)这个标志。 在处理程序中只调用异步信号安全的函数。 所谓异步信号安全的函数(或简称安全的函数)能够被信号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号处理程序中断。 保存和恢复 errno。 许多 Linux 异步信号安全的函数都会在出错返回时设置 errno 在处理程序中调用这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把 errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用 _exit 终止该进程，那么就不需要这样做了。 阻塞所有的信号，保护对共享全局数据结构的访问。 如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。这条规则的原因是从主程序访问一个数据结构 d 通常需要一系列的指令，如果指令序列被访问 d 的处理程序中断，那么处理程序可能会发现 d 的状态不一致，得到不可预知的结果。在访问 d 时暂时阻塞信号保证了处理程序不会中断该指令序列。 用 volatile 声明全局变量。 考虑一个处理程序和一个 main 函数，它们共享一个全局变量 g。处理程序更新 g，main 周期性地读 g， 对于一个优化编译器而言，main 中 g 的值看上去从来没有变化过，因此使用缓存在寄存器中 g 的副本来满足对 g 的每次引用是很安全的。如果这样，main 函数可能永远都无法看到处理程序更新过的值。可以用 volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用 g 时，都要从内存中读取 g 的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。 1volatile int g; 用 sigatomict 声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型 sigatomict 对它的读和写保证会是原子的（不可中断的）。 信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。 进程调度的时机 当前运行的进程运行结束。 当前运行的进程由于某种原因阻塞。 执行完系统调用等系统程序后返回用户进程。 在使用抢占调度的系统中，具有更高优先级的进程就绪时。 分时系统中，分给当前进程的时间片用完。 不能进行进程调度的情况 在中断处理程序执行时。 在操作系统的内核程序临界区内。 其它需要完全屏蔽中断的原子操作过程中。 进程的调度策略 先到先服务调度算法 短作业优先调度算法 优先级调度算法 时间片轮转调度算法 高响应比优先调度算法 多级队列调度算法 多级反馈队列调度算法 进程调度策略的基本设计指标 CPU 利用率 系统吞吐率，即单位时间内 CPU 完成的作业的数量。 响应时间。 周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 平均周转时间 带权周转时间 平均带权周转时间 进程的状态与状态转换进程在运行时有三种基本状态：就绪态、运行态和阻塞态。 运行（running）态：进程占有处理器正在运行的状态。进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。 就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。 各状态之间的转换： 就绪→执行 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。 执行→就绪 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。 执行→阻塞 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。 阻塞→就绪 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。 什么是孤儿进程？僵尸进程? 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程（1号进程）所收养，并由 init 进程对他们完成状态收集工作。 僵尸进程： 进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 获 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程。 什么是线程？ 是进程划分的任务，是一个进程内可调度的实体，是 CPU 调度的基本单位，用于保证程序的实时性，实现进程内部的并发。 线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。 每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 为什么需要线程？线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点： 进程在同一时刻只能做一个任务，很多时候不能充分利用 CPU 资源。 进程在执行的过程中如果发生阻塞，整个进程就会挂起，即使进程中其它任务不依赖于等待的资源，进程仍会被阻塞。 引入线程就是为了解决以上进程的不足，线程具有以下的优点： 从资源上来讲，开辟一个线程所需要的资源要远小于一个进程。 从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间（这种时间的差异主要由于缓存的大量未命中导致）。 从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。 简述线程和进程的区别和联系 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） 进程是资源分配的最小单位，线程是 CPU 调度的最小单位。 通信：由于同一进程中的多个线程具有相同的地址空间，使它们之间的同步和通信的实现，也变得比较容易。进程间通信 IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法，以保证数据的一致性）。 进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。 进程适应于多核、多机分布；线程适用于多核。 多线程模型 多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。 一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux 和 Windows 操作系统家族都是使用一对一模型。 多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。 进程同步的方法操作系统中，进程是具有不同的地址空间的，两个进程是不能感知到对方的存在的。有时候，需要多个进程来协同完成一些任务。 当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争的关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。 进程互斥指若干个进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他要使用该资源的进程必须等待，直到占有资源的进程释放该资源。 当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程的同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。进程互斥本质上也是一种进程同步。 进程的同步方法： 互斥锁 读写锁 条件变量 记录锁(record locking) 信号量 屏障（barrier） 线程同步的方法操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。遇到竞争的线程同时修改同一数据或是协作的线程设置同步点的问题时，需要使用一些线程同步的方法来解决这些问题。 线程同步的方法： 互斥锁 读写锁 条件变量 信号量 自旋锁 屏障（barrier） 进程同步与线程同步有什么区别进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。 死锁是怎样产生的？死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。 产生死锁需要满足下面四个条件： 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。 占有并等待条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。 非抢占条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。 循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。 如何解决死锁问题？解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下: 资源一次性分配，这样就不会再有请求了（破坏请求条件）。 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有并等待条件）。 可抢占资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 什么是虚拟地址，什么是物理地址？地址空间是一个非负整数地址的有序集合。 在一个带虚拟内存的系统中，CPU 从一个有 N=pow(2,n)个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space）,现代系统通常支持 32 位或者 64 位虚拟地址空间。 一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的 M 个字节。 地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。 一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。 主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。 什么是虚拟内存？为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存(VM)。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力： 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。 它为每个进程提供了一致的地址空间，从而简化了内存管理。 它保护了每个进程的地址空间不被其他进程破坏。 为什么要引入虚拟内存？ 虚拟内存作为缓存的工具 虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。 虚拟内存利用 DRAM 缓存来自通常更大的虚拟地址空间的页面。 虚拟内存作为内存管理的工具。操作系统为每个进程提供了一个独立的页表，也就是独立的虚拟地址空间。多个虚拟页面可以映射到同一个物理页面上。 简化链接： 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。 例如：一个给定的linux系统上的每个进程都是用类似的内存格式，对于64为地址空间，代码段总是从虚拟地址）0x400000开始，数据段，代码段，栈，堆等等。 简化加载： 虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页VP，把他们标记为无效（未被缓存） ，将页表条目指向目标文件的起始位置。 加载器从不在磁盘到内存实际复制任何数据，在每个页初次被引用时，虚拟内存系统会按照需要自动的调入数据页。 简化共享： 独立地址空间为OS提供了一个管理用户进程和操作系统自身之间共享的一致机制。 一般：每个进程有各自私有的代码，数据，堆栈，是不和其他进程共享的，这样OS创建页表，将虚拟页映射到不连续的物理页面。 某些情况下，需要进程来共享代码和数据。例如每个进程调用相同的操作系统内核代码，或者C标准库函数。OS会把不同进程中适当的虚拟页面映射到相同的物理页面。 简化内存分配： 虚拟内存向用户提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如malloc），OS分配一个适当k大小个连续的虚拟内存页面，并且将他们映射到物理内存中任意位置的k个任意物理页面，因此操作系统没有必要分配k个连续的物理内存页面，页面可以随机的分散在物理内存中。 虚拟内存作为内存保护的工具。不应该允许一个用户进程修改它的只读段，也不允许它修改任何内核代码和数据结构，不允许读写其他进程的私有内存，不允许修改任何与其他进程共享的虚拟页面。每次CPU生成一个地址时，MMU会读一个PTE，通过在PTE上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。 常见的页面置换算法当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下： ​ 先进先出(FIFO)算法： 思路：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。 实现：按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。 特点：实现简单；性能较差，调出的页面可能是经常访问的 最近最少使用（LRU）算法: 思路： 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 实现：缺页时，计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面 特点：可能达到最优的效果，维护这样的访问链表开销比较大 ​ 当前最常采用的就是LRU算法。 ​ 最不常用算法（Least Frequently Used, LFU） 思路：缺页时，置换访问次数最少的页面 实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面 特点：算法开销大，开始时频繁使用，但以后不使用的页面很难置换 请说一下什么是写时复制？ 如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。 写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。 在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在 fork() 调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。 实时操作系统的概念实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序运行、管理系统资源，并为开发应用程序提供一致的基础。 实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。 优先级反转是什么？如何解决由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。其实,优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时,被阻塞.而此时又有优先级高于占有资源的任务(C)而低于被阻塞的任务(A)的优先级的任务(假设为B)时,于是,占有资源的任务就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行。 目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承(priority inheritance)；另一种被称作优先级极限(priority ceilings)。 优先级继承(priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。 优先级天花板(priority ceilings)优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.(这个优先级称为该资源的优先级天花板)。 简述 selectselect 是一种多路复用技术。其收到所有输入的文件描述符，返回哪些文件有新数据。 其可以设置为阻塞或者非阻塞状态，底层采用 1024 位 bitmap 做实现，因此有文件描述符上限数。 简述 pollpoll 是一种多路复用技术。其收到所有输入的文件描述符，返回哪些文件有新数据。 其通过链表代替了之前 select 的数据结构，使得其没有上限限制。 简述 epollepoll 是一种多路复用技术。其采用一个文件描述符管理多个输入的文件描述符，采用事件回调的方式，提高了程序运行效率。 简述虚拟地址到物理地址转化过程虚拟地址由虚拟页号和页偏移两部分组成。 通过虚拟地址的页面号，首先在快表中查询是否有该映射，查询不成功，在页表中找到该页对应的物理地址。 然后通过页物理地址+页偏移，得到真实的物理地址。 简述页表页表用于存储虚拟地址中的虚拟页面号和物理页面号的映射关系。 除此之外，有些页的读写有限制，页表也通过其他存储位，标记该页访问位，是否在内存中（可能被页面置换出去了）等等。 简述多级页表多级页表用于减少内存的占用。以二级页表为例，虚拟地址被分为 DIR,PAGE和offset 三部分，通过顶级页表和 DIR，寻找到该二级页表的起始位置，再通过二级页表的起始位置和 PAGE，找到页物理地址，最后加上页偏移，即可得到最终的物理地址。 简述快表快表也称为页表高速缓存。其会存储一定数量的页表项，以此加快虚拟地址到物理地址的映射速度。 简述 MMUMMU 即内存管理单元，该硬件负责处理虚拟地址到物理地址的转化工作。快表也存储在 MMU 上。 进程调度算法先来先服务调度算法：创建一个任务队列，一旦有新任务就加入这个队列，CPU 完成一个任务后就从队列取任务。 短作业(进程)优先调度算法：针对较短的作业，优先调给 CPU 工作。 时间片轮转算法：每个时间片依次执行一个任务，时间片结束后将该任务放回任务队列。 多级反馈队列：也按时间片轮转算法执行任务，设置 n 个队列，当第一个队列任务为空，才执行第二个队列，依次类推。 如果在 i 队列的任务在该时间片执行后没有完成，即插入 i+1 号队列。 简述进程组进程组即多个进程的集合,进程组有一个组长,组长进程的 PID 等于进程组的 PGID。 简述协程协程，即用户态线程。我们知道，在 Linux下，线程有 PCB，然后可以占用时间片去调度，但是在用户态线程中，该线程的执行不由内核做调度，由用户自己实现 可以这么理解，在用户进程 A 中，再实现了个调度器，调度用户线程，这些线程不像之前的线程，内核是感知不到的，它们只能感知到 A 的存在，用户态线程之间时间片只能争取内核分给进程 A 的时间片。 IO 模型有哪几种在同步方式上，可以分为同步 IO 和异步 IO 在阻塞方式上，可以分为阻塞 IO 和非阻塞 IO 简述阻塞 IO阻塞和非阻塞描述的是调用方在获取消息过程中的状态，阻塞等待还是立刻返回。阻塞 io 指的是调用方在获取消息的过程中会挂起阻塞，知道获取到消息。 简述非阻塞 IO非阻塞 io 指的是调用方在获取 io 的过程中会立刻返回而不进行挂起。 简述同步 IO同步和异步描述的是一种消息通知的机制，主动等待消息返回还是被动接受消息。同步 io 指的是调用方通过主动等待获取调用返回的结果来获取消息通知。 简述异步 IO异步 io 指的是被调用方通过某种方式（如，回调函数）来通知调用方获取消息。 简述信号驱动 IO信号驱动 IO 即，在内核中注册一个回调函数，当某个事件发生时，内核使用信号，使程序运行回调函数。 简述 IO 多路复用IO 多路复用，即单线程可以监控多个文件描述符是否能进行IO操作的能力。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://pass1on.fun/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机网络知识总结","slug":"计算机网络知识总结","date":"2022-03-24T11:35:17.000Z","updated":"2022-03-24T12:08:49.897Z","comments":true,"path":"2022/03/24/计算机网络知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"计算机网络知识总结","text":"简述 OSI 七层协议OSI 七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层 简述 TCP/IP 五层协议TCP/IP 五层协议包括：物理层，数据链路层，网络层，运输层，应用层 物理层有什么作用主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。 数据链路层有什么作用在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。 网络层有什么作用将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。 传输层有什么作用传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。 会话层有什么作用建立会话：身份验证，权限鉴定等； 保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局； 断开会话：当应用程序或应用层规定的超时时间到期后，OSI 会话层才会释放这条会话。 表示层有什么作用对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。 应用层有什么作用提供应用层协议，如 HTTP 协议，FTP 协议等等，方便应用程序之间进行通信。 TCP 与 UDP 区别TCP 作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信 UDP 作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播 为何 TCP 可靠TCP 有三次握手建立连接，四次挥手关闭连接的机制。 除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。 对于每份报文也存在校验，保证每份报文可靠性。 为何 UDP 不可靠UDP 面向数据报无连接的，数据报发出去，就不保留数据备份了。 仅仅在 IP 数据报头部加入校验和复用。 UDP 没有服务器和客户端的概念。 UDP 报文过长的话是交给 IP 切成小段，如果某段报废报文就废了。 简述 TCP 粘包现象TCP 是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个 tcp 报文中发出去的可能性。 可以简单的理解成客户端调用了两次 send，服务器端一个 recv 就把信息都读出来了。 TCP 粘包现象处理方法固定发送信息长度，或在两个信息之间加入分隔符。 简述 TCP 协议的滑动窗口滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。 简述 TCP 协议的拥塞控制拥塞是指一个或者多个交换点的数据报超载，TCP 又会有重传机制，导致过载。 为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量. 当 cwnd &lt; ssthresh 时，使用慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。 慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd 指数增加。 拥塞避免：cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1。 快恢复之前的策略：发送方判断网络出现拥塞，就把 ssthresh 设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。 快恢复：发送方判断网络出现拥塞，就把 ssthresh 设置为出现拥塞时发送方窗口值的一半，并把 cwnd 设置为 ssthresh 的一半，之后进行拥塞避免。 简述快重传如果在超时重传定时器溢出之前，接收到连续的三个重复冗余 ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。 TCP 三次握手过程 第一次握手:客户端将标志位 SYN 置为 1，随机产生一个值序列号 seq=x，并将该数据包发送给服务端，客户端进入 syn_sent 状态，等待服务端确认。 第二次握手:服务端收到数据包后由标志位 SYN=1 知道客户端请求建立连接，服务端将标志位 SYN 和 ACK 都置为 1,ack=x+1,随机产生一个值 seq=y，并将该数据包发送给客户端以确认连接请求，服务端进入 syn_rcvd 状态。 第三次握手:客户端收到确认后检查,如果正确则将标志位 ACK 为 1，ack=y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入 established 状态，完成三次握手，随后客户端和服务端之间可以开始传输数据了。 为什么 TCP 握手需要三次，两次行不行？不行。TCP 进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值。 如果只是两次握手， 至多只有客户端的起始序列号能被确认， 服务器端的序列号则得不到确认。 简述半连接队列TCP 握手中，当服务器处于 SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。 简述 SYN 攻击SYN 攻击即利用 TCP 协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费 CPU 和内存资源。 优化方式： 缩短 SYN Timeout 时间 记录 IP，若连续受到某个 IP 的重复 SYN 报文，从这个 IP 地址来的包会被一概丢弃。 TCP 四次挥手过程 第一次挥手：客户端发送一个 FIN，用来关闭客户端到服务端的数据传送，客户端进入finwait1 状态。 第二次挥手：服务端收到 FIN 后，发送一个 ACK 给客户端，确认序号为收到序号 +1，服务端进入 Close_wait 状态。此时 TCP 连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。 第三次挥手：服务端发送一个 FIN，用来关闭服务端到客户端的数据传送，服务端进入 Last_ack 状态。 第四次挥手：客户端收到 FIN 后，客户端进入 Time_wait 状态，接着发送一个 ACK 给服务端，确认后，服务端进入 Closed 状态，完成四次挥手。 为什么 TCP 挥手需要 4 次主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即 close。 所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。 为什么四次挥手释放连接时需要等待 2MSLMSL 即报文最大生存时间。设置 2MSL 可以保证上一次连接的报文已经在网络中消失，不会出现与新 TCP 连接报文冲突的情况。 简述 DNS 协议DNS 协议是基于 UDP 的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的 IP 地址，从而给客户端进行访问。 简述 DNS 解析过程1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给 dns 服务器 2、本地 dns 服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找 3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名 dns 服务器 4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的 dns 服务器的地址返回到客户机的 dns 服务器地址 5、客户机的 dns 服务器根据返回的信息接着访问下一级的 dns 服务器 6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的 IP 信息 7、客户机的本地的 dns 服务器会将查询结果返回给我们的客户机 8、客户机根据得到的 ip 信息访问目标主机，完成解析过程 简述 HTTP 协议http 协议是超文本传输协议。它是基于 TCP 协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身 HTTP 是一种无状态的协议。 简述 cookieHTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie 是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据 cookie 辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。 简述 sessionsession 用于标记特定客户端信息，存在在服务器的一个文件里。 一般客户端带 Cookie 对服务器进行访问，可通过 cookie 中的 session id 从整个 session 中查询到服务器记录的关于客户端的信息。 简述 http 状态码和对应的信息1XX：接收的信息正在处理 2XX：请求正常处理完毕 3XX：重定向 4XX：客户端错误 5XX：服务端错误 常见错误码： 301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到 转发和重定向的区别转发是服务器行为。服务器直接向目标地址访问 URL,将相应内容读取之后发给浏览器，用户浏览器地址栏 URL 不变，转发页面和转发到的页面可以共享 request 里面的数据。 重定向是利用服务器返回的状态码来实现的，如果服务器返回 301 或者 302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏 url 会发生改变，而且不能共享数据。 简述 http1.0规定了请求头和请求尾，响应头和响应尾（get post） 每一个请求都是一个单独的连接，做不到连接的复用 简述 http1.1 的改进HTTP1.1 默认开启长连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。 服务端无法主动 push 简述 HTTP 短连接与长连接区别HTTP 中的长连接短连接指 HTTP 底层 TCP 的连接。 短连接： 客户端与服务器进行一次 HTTP 连接操作，就进行一次 TCP 连接，连接结束 TCP 关闭连接。 长连接：如果 HTTP 头部带有参数 keep-alive，即开启长连接网页完成打开后，底层用于传输数据的 TCP 连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。 简述 http2.0 的改进提出多路复用。多路复用前，文件时串行传输的，请求 a 文件，b 文件只能等待，并且连接数过多。引入多路复用，a 文件 b 文件可以同时传输。 引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列 id，服务器就可以进行并行传输数据。 http 与 https 的区别http 所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份. https 具有安全性的 ssl 加密传输协议，加密采用对称加密, https 协议需要到 ca 申请证书，一般免费证书很少，需要交费。 简述 TLS/SSL, HTTP, HTTPS 的关系SSL 全称为 Secure Sockets Layer 即安全套接层，其继任为 TLSTransport Layer Security 传输层安全协议，均用于在传输层为数据通讯提供安全支持。 可以将 HTTPS 协议简单理解为 HTTP协议＋TLS/SSL https 的连接过程 浏览器将支持的加密算法信息发给服务器 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器 客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为 client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。 客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端对称密钥发送给服务器 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 服务器将加密后的密文发送给客户端 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成 Get 与 Post 区别Get：指定资源请求数据，刷新无害，Get 请求的数据会附加到 URL 中，传输数据的大小受到 url 的限制。 Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post 在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。 Get 方法参数有大小限制吗一般 HTTP 协议里并不限制参数大小限制。但一般由于 get 请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使 GET 请求在浏览器实现层面上看会有长度限制。 了解 REST API 吗REST API 全称为表述性状态转移（Representational State Transfer，REST）即利用 HTTP 中 get、post、put、delete 以及其他的 HTTP 方法构成 REST 中数据资源的增删改查操作： Create ： POST Read ： GET Update ： PUT/PATCH Delete： DELETE 浏览器中输入一个网址后，具体发生了什么 进行 DNS 解析操作，根据 DNS 解析的结果查到服务器 IP 地址 通过 ip 寻址和 arp，找到服务器，并利用三次握手建立 TCP 连接 浏览器生成 HTTP 报文，发送 HTTP 请求，等待服务器响应 服务器处理请求，并返回给浏览器 根据 HTTP 是否开启长连接，进行 TCP 的挥手过程 浏览器根据收到的静态资源进行页面渲染 http 请求包含了什么包含：请求方法字段、URL 字段、HTTP 协议版本 产生请求的浏览器类型，请求数据，主机地址。 Put 与 Delete 区别Put 规定默认为更新某一资源，和 Post 一样，一般该操作会对服务器资源进行改变 Delete规定默认为删除某一资源，和 Post 一样，一般该操作会对服务器资源进行改变 简述 DNS 劫持DNS 是指将网页域名翻译为对应的 IP 的一种方法。DNS 劫持指攻击者篡改结果，使用户对域名的解析 IP 变成了另一个 IP。 http 的 request 具体格式http request 部分报文分三部分。第一部分是请求行，第二部分是请求头，第三部分是请求实体。 请求行包括：请求方法（GET、HEAD、PUT、POST、TRACE、OPTIONS、DELETE），请求的 url，协议版本格式（http1.0/http1.1） 请求头包括一些附加信息，比如说： Host：域名或 ip 加端口号 User-Agent：发送请求的应用程序名称，比如 XX 浏览器 Connection：连接是不是长连接 Accept-Charset：编码样式 Accept-Encoding：数据压缩格式 请求实体： 比如 post 就会把需要的数据放入请求实体中。 http 的 response 具体格式HTTP响应报文分为三部分。第一部分是状态行，第二部分是响应头部，第三部分是响应正文。 状态行由协议版本，状态码，状态码描述三部分组成。 响应头部包含了一些附加信息，如： server：服务器（apache 等） content-type：如 application/json content-charset：编码格式 content-encoding：数据压缩格式 响应正文：响应的详细回传数据。 简述 dos 攻击DoS 是 Denial of Service 的简称，也称为拒绝服务攻击，通过发送大量的无用请求数据包给服务器，耗尽服务器资源，从而无法通过正常的访问服务器资源，导致服务器崩溃。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://pass1on.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"JVM 知识总结","slug":"JVM-知识总结","date":"2022-03-24T11:11:58.000Z","updated":"2022-03-24T11:34:36.179Z","comments":true,"path":"2022/03/24/JVM-知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/JVM-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"JVM 知识总结","text":"简述 JVM 内存模型线程私有的运行时数据区: 程序计数器、Java 虚拟机栈、本地方法栈。 线程共享的运行时数据区:Java 堆、方法区。 简述程序计数器程序计数器表示当前线程所执行的字节码的行号指示器。 程序计数器不会产生 StackOverflowError 和 OutOfMemoryError。 简述虚拟机栈Java 虚拟机栈用来描述 Java 方法执行的内存模型。线程创建时就会分配一个栈空间，线程结束后栈空间被回收。 栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和返回地址等信息。 虚拟机栈会产生两类异常： StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。 OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。 简述本地方法栈本地方法栈与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为本地方法服务。可以将虚拟机栈看作普通的 java 函数对应的内存模型，本地方法栈看作由 native 关键词修饰的函数对应的内存模型。 本地方法栈会产生两类异常： StackOverflowError：线程请求的栈深度大于虚拟机允许的深度抛出。 OutOfMemoryError：如果 JVM 栈容量可以动态扩展，虚拟机栈占用内存超出抛出。 简述 JVM 中的堆堆主要作用是存放对象实例，Java 里几乎所有对象实例都在堆分配内存，堆也是内存管理中最大的一块。Java 的垃圾回收主要就是针对堆这一区域进行。 可通过 -Xms 和 -Xmx 设置堆的最小和最大容量。 堆会抛出 OutOfMemoryError 异常。 简述方法区方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。 JDK6 之前使用永久代实现方法区，容易内存溢出。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中抛弃永久代，改用在本地内存中实现的元空间来实现方法区，把 JDK7 中永久代内容移到元空间。 方法区会抛出 OutOfMemoryError 异常。 简述运行时常量池运行时常量池存放常量池表，用于存放编译器生成的各种字面量与符号引用。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。除此之外，也会存放字符串基本类型。 JDK8 之前，放在方法区，大小受限于方法区。JDK8 将运行时常量池存放堆中。 简述直接内存直接内存也称为堆外内存，就是把内存对象分配在 JVM 堆外的内存区域。这部分内存不是虚拟机管理，而是由操作系统来管理。 Java 通过通过 DriectByteBuffer 对其进行操作，避免了在 Java 堆和 Native 堆来回复制数据。 简述 Java 创建对象的过程 检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。 通过检查通过后虚拟机将为新生对象分配内存。 完成内存分配后虚拟机将成员变量设为零值 设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。 执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。 简述 JVM 给对象分配内存的策略 指针碰撞： 这种方式在内存中放一个指针作为分界指示器将使用过的内存放在一边，空闲的放在另一边，通过指针挪动完成分配。 空闲列表： 对于 Java 堆内存不规整的情况，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。 Java 对象内存分配是如何保证线程安全的 对分配内存空间采用 CAS 机制，配合失败重试的方式保证更新操作的原子性。该方式效率低。 每个线程在 Java 堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配。一般采用这种策略。 简述对象的内存布局对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。 对象头主要包含两部分数据： MarkWord、类型指针。MarkWord 用于存储哈希码（HashCode）、GC分代年龄、锁状态标志位、线程持有的锁、偏向线程 ID 等信息。 类型指针即对象指向他的类元数据指针，如果对象是一个 Java 数组，会有一块用于记录数组长度的数据， 实例数据存储代码中所定义的各种类型的字段信息。 对齐填充起占位作用。HotSpot 虚拟机要求对象的起始地址必须是8的整数倍，因此需要对齐填充。 如何判断对象是否是垃圾引用计数法：设置引用计数器，对象被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。会存在对象间循环引用的问题，一般不使用这种方法。 可达性分析：通过 GC Roots 的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，如果某个对象没有被搜到，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。 简述 Java 的引用类型强引用：被强引用关联的对象不会被回收。一般采用 new 方法创建强引用。 软引用：被软引用关联的对象只有在内存不够的情况下才会被回收。一般采用 SoftReference 类来创建软引用。 弱引用：垃圾收集器碰到即回收，也就是说它只能存活到下一次垃圾回收发生之前。一般采用 WeakReference 类来创建弱引用。 虚引用：无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用。 简述标记清除算法、标记整理算法和标记复制算法标记清除算法：先标记需清除的对象，之后统一回收。这种方法效率不高，会产生大量不连续的碎片。 标记整理算法：先标记存活对象，然后让所有存活对象向一端移动，之后清理端边界以外的内存 标记复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。 简述分代收集算法根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代，对这两块采用不同的算法。 新生代使用：标记复制算法 老年代使用：标记清除或者标记整理算法 简述 Serial 垃圾收集器单线程串行收集器。垃圾回收的时候，必须暂停其他所有线程。新生代使用标记复制算法，老年代使用标记整理算法。简单高效。 简述 ParNew 垃圾收集器可以看作 Serial 垃圾收集器的多线程版本，新生代使用标记复制算法，老年代使用标记整理算法。 简述 Parallel Scavenge 垃圾收集器注重吞吐量，即 cpu 运行代码时间 / cpu 耗时总时间（cpu 运行代码时间+ 垃圾回收时间）。新生代使用标记复制算法，老年代使用标记整理算法。 简述 CMS 垃圾收集器注重最短时间停顿。CMS 垃圾收集器为最早提出的并发收集器，垃圾收集线程与用户线程同时工作。采用标记清除算法。该收集器分为初始标记、并发标记、并发预清理、并发清除、并发重置这么几个步骤。 初始标记：暂停其他线程(stop the world)，标记与 GC roots 直接关联的对象。 并发标记：可达性分析过程(程序不会停顿)。 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象，重新标记，暂停虚拟机（stop the world）扫描 CMS 堆中剩余对象。 并发清除：清理垃圾对象，(程序不会停顿)。 并发重置：重置 CMS 收集器的数据结构。 简述 G1 垃圾收集器和之前收集器不同，该垃圾收集器把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。 初始标记：标记与 GC roots 直接关联的对象。 并发标记：可达性分析。 最终标记，对并发标记过程中，用户线程修改的对象再次标记一下。 筛选回收：对各个 Region 的回收价值和成本进行排序，然后根据用户所期望的 GC 停顿时间制定回收计划并回收。 简述 Minor GCMinor GC 指发生在新生代的垃圾收集，因为 Java 对象大多存活时间短，所以 Minor GC 非常频繁，一般回收速度也比较快。 简述 Full GCFull GC 是清理整个堆空间—包括年轻代和永久代。调用 System.gc(),老年代空间不足，空间分配担保失败，永生代空间不足会产生 full gc。 常见内存分配策略大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。 大对象需要大量连续内存空间，直接进入老年代区分配。 如果经历过第一次 Minor GC 仍然存活且能被 Survivor 容纳，该对象就会被移动到 Survivor 中并将年龄设置为 1，并且每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。 如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 的一半，年龄不小于该年龄的对象就可以直接进入老年代。 空间分配担保。MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。如果不，JVM 会查看 HandlePromotionFailure 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将 Minor GC，否则改成一次 FullGC。 简述 JVM 类加载过程加载： 通过全类名获取类的二进制字节流. 将类的静态存储结构转化为方法区的运行时数据结构。 在内存中生成类的 Class 对象，作为方法区数据的入口。 验证：对文件格式，元数据，字节码，符号引用等验证正确性。 准备：在方法区内为类变量分配内存并设置为 0 值。 解析：将符号引用转化为直接引用。 初始化：执行类构造器 clinit 方法，真正初始化。 简述 JVM 中的类加载器BootstrapClassLoader 启动类加载器：加载 /lib 下的 jar 包和类。C++ 编写。 ExtensionClassLoader 扩展类加载器： /lib/ext 目录下的 jar 包和类。java 编写。 AppClassLoader 应用类加载器，加载当前 classPath 下的 jar 包和类。java 编写。 简述双亲委派机制一个类加载器收到类加载请求之后，首先判断当前类是否被加载过。已经被加载的类会直接返回，如果没有被加载，首先将类加载请求转发给父类加载器，一直转发到启动类加载器，只有当父类加载器无法完成时才尝试自己加载。 加载类顺序：BootstrapClassLoader-&gt;ExtensionClassLoader-&gt;AppClassLoader-&gt;CustomClassLoader 检查类是否加载顺序： CustomClassLoader-&gt;AppClassLoader-&gt;ExtensionClassLoader-&gt;BootstrapClassLoader 双亲委派机制的优点 避免类的重复加载。相同的类被不同的类加载器加载会产生不同的类，双亲委派保证了 java 程序的稳定运行。 保证核心 API 不被修改。 如何破坏双亲委派机制重载 loadClass() 方法，即自定义类加载器。 如何构建自定义类加载器 新建自定义类继承自 java.lang.ClassLoader 重写 findClass、loadClass、defineClass 方法 JVM 常见调优参数 -Xms 初始堆大小 -Xmx 最大堆大小 -XX:NewSize 年轻代大小 -XX:MaxNewSize 年轻代最大值 -XX:PermSize 永生代初始值 -XX:MaxPermSize 永生代最大值 -XX:NewRatio 新生代与老年代的比例 调用 system.gc() 一定会发生垃圾收集吗？为什么？调用 System.gc() 的时候，其实并不会马上进行垃圾回收,只会把这次 gc 请求记录下来。 需配合 System.runFinalization() 才会进行真正回收。 静态变量存储位置在 1.8 以前，静态成员变量存在方法区，在 1.8 后，由于 JDK8 取消永生代，静态变量存储到了堆中。 内存溢出和内存泄漏内存溢出：程序在申请内存时，此时已用内存过多，没有足够的剩余内存空间供其使用。 内存泄漏：程序在申请内存后，不能完全释放已申请的内存空间。 垃圾收集器种类串行收集器:Serial,Serial Old 并行收集器:Parallel Scavenge,Parallel Old 并发收集器:CMS,G1 简述字符串常量池JVM 为了提升字符串的效率，提出了字符串常量池，可以简单理解为为字符串开辟了一个缓存空间。 在新建 String 类型数据时，首先判断字符串常量池是否包含该字符串。如果包含直接返回字符串常量池数据实例。 如果不包含，则实例化该字符串，并放入字符串常量池中。 为什么需要分代收集算法对于大部分对象，存活时间极短，而只有少部分对象存活时间较长。 对于存活时间短的对象，可以采用标记复制算法，加快垃圾收集效率。如果采用标记整理或标记清除，代价太大，适用性不高 对于存活时间长的数据，采用标记整理或标记清除效率更高。 对于这两种不同存活时间的对象，采用不同的垃圾收集算法，可以提高整体的运行效率。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://pass1on.fun/tags/JVM/"},{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}]},{"title":"Java 多线程知识总结","slug":"Java-多线程知识总结","date":"2022-03-24T10:38:11.000Z","updated":"2022-03-24T11:11:12.757Z","comments":true,"path":"2022/03/24/Java-多线程知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"Java 多线程知识总结","text":"简述 Java 内存模型（JMM）java 内存模型定义了程序中各种变量的访问规则。其规定所有变量都存储在主内存，线程均有自己的工作内存。 工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。操作完成后，线程的工作内存通过缓存一致性协议将操作完的数据刷回主存。 简述 as-if-serial编译器等会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果和用户原始程序输出预定结果一致。 简述 happens-before 八大原则程序次序规则：一个线程内写在前面的操作先行发生于后面的。 锁定规则： unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作。 线程启动规则：线程的 start 方法先行发生于线程的每个动作。 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。 线程终止规则：线程中所有操作先行发生于对线程的终止检测。 对象终结规则：对象的初始化先行发生于 finalize 方法。 传递性规则：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C as-if-serial 和 happens-before 的区别as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。 简述原子性操作一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。 简述线程的可见性可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile,synchronized,final 都能保证可见性。 简述有序性即虽然多线程存在并发和指令优化等操作，在本线程内观察该线程的所有执行操作是有序的。 简述 Java 中 volatile 关键字作用 保证变量对所有线程的可见性。 当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。 禁止指令重排序优化。使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相当于一个内存屏障，编译器不会将后面的指令重排到内存屏障之前。 Java 线程的实现方式 实现 Runnable 接口。 继承 Thread 类。 实现 Callable 接口。 简述 Java 线程的状态线程状态有 New, RUNNABLE, BLOCK, WAITING, TIMED_WAITING, THERMINATED NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。 RUNNABLE：运行状态。其表示线程正在 JVM 中执行，但是这个执行，不一定真的在跑，也可能在排队等 CPU。 BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。 WAITING：等待状态。线程内 run 方法运行完语句 Object.wait()/Thread.join() 进入该状态。 TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用 Thread.sleep(long) Object.wait(long) Thread.join(long) 进入状态。其中这些参数代表等待的时间。 TERMINATED：结束状态。线程调用完 run 方法进入该状态。 简述线程通信的方式 volatile 关键词修饰变量，保证所有线程对变量访问的可见性。 synchronized 关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。 wait/notify 方法。 IO 通信。 简述线程池没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后执行接下来任务，复用已创建的线程，降低开销、控制最大并发数。 线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。 将任务派发给线程池时，会出现以下几种情况 核心线程池未满，创建一个新的线程执行任务。 如果核心线程池已满，工作队列未满，将线程存储在工作队列。 如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。 如果超过大小线程数，按照拒绝策略来处理任务。 线程池参数 corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。 maximumPoolSize：线程池能够容纳同时执行的线程最大数。 keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。 workQueue：工作队列。 threadFactory：线程工厂，用来生产一组相同任务的线程。 handler：拒绝策略。有以下几种拒绝策略： AbortPolicy：丢弃任务并抛出异常 CallerRunsPolicy： 重新尝试提交该任务 DiscardOldestPolicy：抛弃队列里等待最久的任务并把当前任务加入队列 DiscardPolicy ：表示直接抛弃当前任务但不抛出异常。 线程池创建方法 newFixedThreadPool，创建固定大小的线程池。 newSingleThreadExecutor，使用单线程线程池。 newCachedThreadPool，maximumPoolSize 设置为 Integer 最大值，工作完成后会回收工作线程 newScheduledThreadPool：支持定期及周期性任务执行，不回收工作线程。 newWorkStealingPool：一个拥有多个任务队列的线程池。 简述 Executor 框架Executor 框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor 框架实现类的 Execute 方法就可以提交任务。产生线程池的函数 ThreadPoolExecutor 也是 Executor 的具体实现类。 简述 Executor 的继承关系 Executor：一个接口，其定义了一个接收 Runnable 对象的方法 executor，该方法接收一个 Runable 实例执行这个任务。 ExecutorService：Executor 的子类接口，其定义了一个接收 Callable 对象的方法，返回 Future 对象，同时提供 execute 方法。 ScheduledExecutorService：ExecutorService 的子类接口，支持定期执行任务。 AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。 Executors：实现 ExecutorService 接口的静态工厂类，提供了一系列工厂方法用于创建线程池。 ThreadPoolExecutor：继承 AbstractExecutorService，用于创建线程池。 ForkJoinPool: 继承 AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于 map reduce。 ThreadPoolExecutor：继承T hreadPoolExecutor，实现 ScheduledExecutorService，用于创建带定时任务的线程池。 简述线程池的状态 Running：能接受新提交的任务，也可以处理阻塞队列的任务。 Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于 running 时调用 shutdown 方法，会进入该状态。 Stop：不接受新任务，不处理存量任务，调用 shutdownnow 进入该状态。 Tidying：所有任务已经终止了，worker_count（有效线程数）为 0。 Terminated：线程池彻底终止。在 tidying 模式下调用 terminated 方法会进入该状态。 简述阻塞队列阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有： ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。 LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。 PriorityBlockingQueue：阻塞优先队列。 DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素 SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作 LinkedTransferQueue：与 LinkedBlockingQueue 相比多一个 transfer 方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。 LinkedBlockingDeque：双向阻塞队列。 谈一谈 ThreadLocalThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。 set 给 ThreadLocalMap 设置值。 get 获取 ThreadLocalMap。 remove 删除 ThreadLocalMap 类型的对象。 存在的问题 对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。 内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。 聊聊你对 Java 并发包下 unsafe 类的理解对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。 Java 有个类叫 Unsafe 类，这个类类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。 JAVA 中的乐观锁与 CAS 算法对于乐观锁，开发者认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。 到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。 乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。 CAS 算法的思路如下： 该算法认为不同线程对变量的操作时产生竞争的情况比较少。 该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。 如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。 如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。 ABA 问题及解决方法简述CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。 juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。 简述常见的 Atomic 类在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的 ++ 或者 – 方案，使用 synchronized 关键字和 lock 固然可以实现，但代价比较大，此时用原子类更加方便。 基本数据类型的原子类有： AtomicInteger 原子更新整形 AtomicLong 原子更新长整型 AtomicBoolean 原子更新布尔类型 Atomic数组类型有： AtomicIntegerArray 原子更新整形数组里的元素 AtomicLongArray 原子更新长整型数组里的元素 AtomicReferenceArray 原子更新引用类型数组里的元素。 Atomic引用类型有 AtomicReference 原子更新引用类型 AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记 AtomicStampedReference 原子更新带有版本号的引用类型 FieldUpdater类型： AtomicIntegerFieldUpdater 原子更新整形字段的更新器 AtomicLongFieldUpdater 原子更新长整形字段的更新器 AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器 简述 Atomic 类基本实现原理以 AtomicIntger 为例： 方法 getAndIncrement：以原子方式将当前的值加 1，具体实现为： 在 for 死循环中取得 AtomicInteger 里存储的数值 对 AtomicInteger 当前的值加 1 调用 compareAndSet 方法进行原子更新 先检查当前数值是否等于 expect 如果等于则说明当前值没有被其他线程修改，则将值更新为 next， 如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。 简述 CountDownLatchcountDownLatch 这个类使一个线程等待其他线程各自执行完毕后再执行。 是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用 countDown 方法，计数器的值就减 1，当计数器的值为 0 时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。 只能一次性使用，不能 reset。 简述 CyclicBarrierCyclicBarrier 主要功能和 countDownLatch 类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。 简述 SemaphoreSemaphore 即信号量。 Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为 0,线程进入休眠。 简述 ExchangerExchanger 类可用于两个线程之间交换信息。可简单地将 Exchanger 对象理解为一个包含两个格子的容器，通过 exchanger 方法可以向两个格子中填充信息。线程通过 exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。 简述 ConcurrentHashMapJDK7 采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。 get 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。 put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。 JDK8 的改进 取消分段锁机制，采用 CAS 算法进行值的设置，如果 CAS 失败再使用 synchronized 加锁添加元素 引入红黑树结构，当某个槽内的元素个数超过 8 且 Node数组容量大于 64 时，链表转为红黑树。 使用了更加优化的方式统计集合内的元素数量。 Synchronized 底层实现原理Java 对象底层都关联一个的 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。 synchronized 在 JVM 编译后会产生 monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。 执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。 Synchronized 关键词使用方法 直接修饰某个实例方法 直接修饰某个静态方法 修饰代码块 简述 Java 偏向锁JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。 其申请流程为： 首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断； 判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4； 判断是否需要重偏向。如果不用的话，直接获得偏向锁； 利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。 简述轻量级锁轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。 其申请流程为： 如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。 虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针 如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。 如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧 如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行 如果不是则说明锁对象已经被其他线程抢占。 如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。 简述锁优化策略即自适应自旋、锁消除、锁粗化、锁升级等策略偏。 简述 Java 的自旋锁线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。 简述自适应自旋锁自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。 简述锁粗化锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。 简述锁消除锁消除是一种更为彻底的优化，在编译时，java 编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。 简述 Lock 与 ReentrantLockLock 接是 java 并发包的顶层接口。 可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。 简述 AQSAQS（AbstractQuenedSynchronizer）抽象的队列式同步器。 AQS 是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。 AQS 是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。 子类通过继承同步器并实现它的抽象方法 getState、setState 和 compareAndSetState 对同步状态进行更改。 AQS 获取独占锁/释放独占锁原理获取：（acquire） 调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。 调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。 释放：（release） 调用 tryRelease 方法释放同步状态 调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。 AQS 获取共享锁/释放共享锁原理获取锁（acquireShared） 调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。 释放（releaseShared） 释放，并唤醒后续处于等待状态的节点。 线程池类型 newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲 1 分钟后自动销毁。 newFixedThreadPool 指定工作线程数量线程池。 newSingleThreadExecutor 单线程 Executor。 newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。 newSingleThreadScheduledExecutor 支持定时任务的单线程 Executor。 synchronized 关键字作用保证只有一个线程可以获取对象的锁,并执行代码块,其他线程不能在该线程执行代码块时执行。 简述三色标记法三色标记法是垃圾收集器 CMS 和 G1 使用的标记方法，该方法把对象分为三种颜色： 白色，该对象尚被未访问。 灰色，该对象已被访问，但该对象引用的其他对象并没有被访问。 黑色，该对象和引用的其他对象均被访问。 因此，对三色标记法来说，所有对象都可以看作由白色集合，黑色集合，灰色集合组成。通过这种标记方法的访问过程如下： 初始所有对象均在白色集合 将 GC root 直接引用的对象移动至灰色集合。 从灰色集合中取出一个对象，将该对象引用的白色集合对象，移动至灰色集合 移动完成后，将该对象移动至黑色集合 重复 3-4 操作。 锁升级过程 无锁状态。最开始处于无锁状态。 偏向锁。如果被一个线程持有，变成偏向锁状态。 轻量级锁。如果该偏向锁被另一个线程争抢，锁升级为轻量级锁。 重量级锁。轻量级锁继续升级，变为重量级锁状态。 threadlocal 应用场景对于数据库中，每个线程通过 threadlocal 维护自己和该线程对应客户端对于数据库的连接。 为什么 threadlocal 要用弱引用为了保证当使用完成后，该 threadlocal 可以被 JVM 回收，不会产生内存泄漏的情况。 synchronized 和 lock 的区别 Synchronized 是关键字，内置语言实现，即其定义的层次在 JVM 上，Lock 是接口，需要具体实现类，比如 ReentrantLock。 Synchronized 在线程发生异常时 JVM 会自动释放锁。Lock 不会，所以需要在 finally 语句段中实现释放锁逻辑。 Synchronized 可重入 不可中断 非公平。Lock 可重入 可判断 可公平。 Mark word是什么Mark word是对象头中的一部分，其中存储了对象的哈希码，GC 分代年龄，锁状态标志，偏向线程 ID 等信息。 Java 线程状态和操作系统线程有什么不同Java 多线程的新建对应操作系统的新建状态。 Java 多线程的 Runnable 状态对应操作系统的就绪和运行状态。 Java 多线程的阻塞，等待和限时等待，对应操作系统的阻塞状态。 Java 多线程的终止状态，对应操作系统的终止状态。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"多线程","slug":"多线程","permalink":"https://pass1on.fun/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java 基础知识总结","slug":"Java-基础知识总结","date":"2022-03-24T09:22:34.000Z","updated":"2022-03-24T10:37:16.737Z","comments":true,"path":"2022/03/24/Java-基础知识总结/","link":"","permalink":"https://pass1on.fun/2022/03/24/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"Java 基础知识总结","text":"Java 语言具有哪些特点？ Java 为面向对象的语言。它能够直接反应现实生活中的对象。 具有平台无关性。java 利用 Java 虚拟机运行字节码，无论是在 Windows、Linux 还是 MacOS 等其它平台对 Java 程序进行编译，编译后的程序可在其它平台运行。 Java 为解释型语言，编译器把 Java 代码编译成平台无关的中间代码，然后在 JVM 上解释运行，具有很好的可移植性。 Java 提供了很多内置类库。如对多线程支持，对网络通信支持，最重要的一点是提供了垃圾回收器。 Java 具有较好的安全性和健壮性。Java 提供了异常处理和垃圾回收机制，去除了 C++ 难以理解的指针特性。 Java 语言提供了对 Web 应用开发的支持。 面向对象的三大特性？ 继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。 封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。 多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。 字节序定义以及Java属于哪种字节序？字节序是指多字节数据在计算机内存中存储或网络传输时个字节的存储顺序。通常由小端和大端两组方式。 小端：低位字节存放在内存的低地址端，高位字节存放在内存的高地址端。 大端：高位字节存放在内存的低地址端，低位字节存放在内存的高地址端。 Java 语言的字节序是大端。 JDK与JRE有什么区别？ JDK：Java 开发工具包(Java Development Kit)，提供了 Java 的开发环境和运行环境。 JRE：Java 运行环境(Java Runtime Environment)，提供了 Java 运行所需的环境。 JDK 包含了 JRE。如果只运行 Java 程序，安装 JRE 即可。要编写 Java 程序需安装 JDK。 简述Java访问修饰符 default: 默认访问修饰符，在同一包内可见 private: 在同一类内可见，不能修饰类 protected : 对同一包内的类和所有子类可见，不能修饰类 public: 对所有类可见 构造方法、成员变量初始化以及静态成员变量三者的初始化顺序？先后顺序：静态成员变量、成员变量、构造方法。 详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。 接口和抽象类的相同点和区别？相同点: 都不能被实例化。 接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化。 不同点： 接口只能有方法定义，不能有方法的实现，而抽象类可以有方法的定义与实现。 实现接口的关键字为 implements,继承抽象类的关键字为 extends。一个类可以实现多个接口，只能继承一个抽象类。 当子类和父类之间存在逻辑上的层次结构，推荐使用抽象类，有利于功能的累积。当功能不需要，希望支持差别较大的两个或更多对象间的特定交互行为，推荐使用接口。使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法。 为什么 Java 语言不支持多重继承？ 为了程序的结构能够更加清晰从而便于维护。假设 Java 语言支持多重继承，类 C 继承自类 A 和类 B,如果类 A 和 B 都有自定义的成员方法 f() ,那么当代码中调用类 C 的 f() 会产生二义性。Java 语言通过实现多个接口间接支持多重继承，接口由于只包含方法定义，不能有方法的实现，类 C 继承接口 A 与接口 B 时即使它们都有方法 f() ,也不能直接调用方法，需实现具体的 f() 方法才能调用，不会产生二义性。 多重继承会使类型转换、构造方法的调用顺序变得复杂，会影响到性能。 Java 提供的多态机制？Java 提供了两种用于多态的机制，分别是重载与覆盖。 重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。 覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法。 重载与覆盖的区别？ 覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。 覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。 覆盖要求参数列表相同；重载要求参数列表不同。 覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。 重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。 final、finally 和 finalize 的区别是什么？ final 用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、类不可继承。 finally 作为异常处理的一部分，只能在 try/catch 语句中使用，finally 附带一个语句块用来表示这个语句最终一定被执行，经常被用在需要释放资源的情况下。 finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的 finalize() 方法。当垃圾回收器准备好释放对象占用空间时，首先会调用 finalize() 方法，并在下一次垃圾回收动作发生时真正回收对象占用的内存。 出现在 Java 程序中的 finally 代码块是否一定会执行？当遇到下面情况不会执行。 当程序在进入 try 语句块之前就出现异常时会直接结束。 当程序在 try 块中强制退出时，如使用 System.exit(0)，也不会执行 finally 块中的代码。 其它情况下，在 try/catch/finally 语句执行的时候，try 块先执行，当有异常发生，catch 和 finally 进行处理后程序就结束了，当没有异常发生，在执行完 finally 中的代码后，后面代码会继续执行。值得注意的是，当 try/catch 语句块中有 return 时，finally 语句块中的代码会在 return 之前执行。如果 try/catch/finally 块中都有 return 语句，finally 块中的 return 语句会覆盖 try/catch 模块中的 return 语句。 Java 语言中关键字 static 的作用是什么？static 的主要作用有两个： 为某种特定数据类型或对象分配与创建对象个数无关的单一的存储空间。 使得某个方法或属性与类而不是对象关联在一起，即在不创建对象的情况下可通过类直接调用方法或使用类的属性。 具体而言 static 又可分为 4 种使用方式： 修饰成员变量。用 static 关键字修饰的静态变量在内存中只有一个副本。只要静态变量所在的类被加载，这个静态变量就会被分配空间，可以使用’’类.静态变量’’和’’对象.静态变量’’的方法使用。 修饰成员方法。static 修饰的方法无需创建对象就可以被调用。static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法，只能访问所属类的静态成员变量和静态成员方法。 修饰代码块。JVM 在加载类的时候会执行 static 代码块。static 代码块常用于初始化静态变量。static 代码块只会被执行一次。 修饰内部类。static 内部类可以不依赖外部类实例对象而被实例化。静态内部类不能与外部类有相同的名字，不能访问普通成员变量，只能访问外部类中的静态成员和静态成员方法。 Java 代码块执行顺序 父类静态代码块（只执行一次） 子类静态代码块（只执行一次） 父类构造代码块 父类构造函数 子类构造代码块 子类构造函数 普通代码块 Java 中一维数组和二维数组的声明方式？一维数组的声明方式： type arrayName[] type[] arrayName 二维数组的声明方式： type arrayName[][] type[][] arrayName type[] arrayName[] 其中 type 为基本数据类型或类，arrayName 为数组名字。 String 和 StringBuffer 有什么区别？String 用于字符串操作，属于不可变类。String 对象一旦被创建，其值将不能被改变。而 StringBuffer 是可变类，当对象创建后，仍然可以对其值进行修改。 判等运算符 == 与 equals 的区别？== 比较的是引用，equals比较的是内容。 如果变量是基础数据类型，**==** 用于比较其对应值是否相等。如果变量指向的是对象, == 用于比较两个对象是否指向同一块存储空间。 equals 是 Object 类提供的方法之一，每个 Java 类都继承自 Objec t类，所以每个对象都具有 equals 这个方法。Object 类中定义的 equals 方法内部是直接调用 == 比较对象的。但通过覆盖的方法可以让它不是比较引用而是比较数据内容。 为什么要把 String 设计为不变量？ 节省空间：字符串常量存储在 JVM 的字符串池中可以被用户共享。 提高效率：String 会被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。 安全：String 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。 序列化是什么？序列化是一种将对象转换成字节序列的过程，用于解决在对对象流进行读写操作时所引发的问题。序列化可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把该流读取出来重新构造成一个相同的对象。 简述 Java 中 Class 对象java 中对象可以分为实例对象和 Class 对象，每一个类都有一个 Class 对象，其包含了与该类有关的信息。 获取 Class 对象的方法： Class.forName(“类的全限定名”) 实例对象.getClass() 类名.class Java 反射机制是什么？Java 反射机制是指在程序的运行过程中可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。反射机制使得 Java 具有动态获取程序信息和动态调用对象方法的能力。可以通过以下类调用反射 API。 Class 类：可获得类属性方法 Field 类：获得类的成员变量 Method 类：获取类的方法信息 Construct 类：获取类的构造方法等信息 简述注解Java 注解用于为 Java 代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。 其可以用于提供信息给编译器，在编译阶段时给软件提供信息进行相关的处理，在运行时处理写相应代码，做对应操作。 简述元注解元注解可以理解为注解的注解，即在注解中使用，实现想要的功能。其具体分为： @Retention: 表示注解存在阶段是保留在源码，还是在字节码（类加载）或者运行期（JVM 中运行）。 @Target：表示注解作用的范围。 @Documented：将注解中的元素包含到 Javadoc 中去。 @Inherited：一个被 @Inherited 注解了的注解修饰了一个父类，如果他的子类没有被其他注解修饰，则它的子类也继承了父类的注解。 @Repeatable：被这个元注解修饰的注解可以同时作用一个对象多次，但是每次作用注解又可以代表不同的含义。 简述 Java 异常的分类Java 异常分为 Error（程序无法处理的错误），和 Exception（程序本身可以处理的异常）。这两个类均继承 Throwable。 Error 常见的有 StackOverFlowError,OutOfMemoryError 等等。 Exception 可分为运行时异常和非运行时异常。对于运行时异常，可以利用 try catch 的方式进行处理，也可以不处理。对于非运行时异常，必须处理，不处理的话程序无法通过编译。 简述 throw 与 throws 的区别throw 一般是用在方法体的内部，由开发者定义当程序语句出现问题后主动抛出一个异常。 throws 一般用于方法声明上，代表该方法可能会抛出的异常列表。 简述泛型泛型，即“参数化类型”，解决不确定对象具体类型的问题。在编译阶段有效。在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型在类中称为泛型类、接口中称为泛型接口和方法中称为泛型方法。 简述泛型擦除Java 编译器生成的字节码是不包涵泛型信息的，泛型类型信息将在编译处理是被擦除，这个过程被称为泛型擦除。 简述 Java 基本数据类型 byte：占用 1 个字节，取值范围 -128 ~ 127 short：占用 2 个字节，取值范围 -2^15^ ~ 2^15^-1 int：占用 4 个字节，取值范围 -2^31^ ~ 2^31^-1 long：占用 8 个字节 float：占用 4 个字节 double：占用 8 个字节 char：占用 2 个字节 boolean：占用大小根据实现虚拟机不同有所差异 简述自动装箱拆箱对于 Java 基本数据类型，均对应一个包装类。 装箱就是自动将基本数据类型转换为包装器类型，如 int-&gt;Integer 拆箱就是自动将包装器类型转换为基本数据类型，如 Integer-&gt;int 简述重载与重写的区别重写即子类重写父类的方法，方法对应的形参和返回值类型都不能变。 重载即在一个类中，方法名相同，参数类型或数量不同。 简述 Java 的多态Java 多态可以分为编译时多态和运行时多态。 编译时多态主要指方法的重载，即通过参数列表的不同来区分不同的方法。 运行时多态主要指继承父类和实现接口时，可使用父类引用指向子类对象。 运行时多态的实现：主要依靠方法表，方法表中最先存放的是 Object 类的方法，接下来是该类的父类的方法，最后是该类本身的方法。如果子类改写了父类的方法，那么子类和父类的那些同名方法共享一个方法表项，都被认作是父类的方法。因此可以实现运行时多态。 简述抽象类与接口的区别抽象类：体现的是 is-a 的关系，如对于 man is a person，就可以将 person 定义为抽象类。 接口：体现的是 can 的关系。是作为模板实现的。如设置接口 fly，plane 类和 bird 类均可实现该接口。 一个类只能继承一个抽象类，但可以实现多个接口。 简述 == 与 equals 方法的区别对于 ==，在基本数据类型比较时，比较的是对应的值，对引用数据类型比较时，比较的是其内存的存放地址。 对于 equals 方法，在该方法未被重写时，其效果和 == 一致，但用户可以根据对应需求对判断逻辑进行改写，比如直接比较对象某个属性值是否相同，相同则返回 true，不同则返回 false。需保证 equals 方法相同对应的对象 hashCode 也相同。 简述 Object 类常用方法 hashCode：通过对象计算出的散列码。用于 map 型或 equals 方法。 需要保证同一个对象多次调用该方法，总返回相同的整型值。 equals：判断两个对象是否一致。需保证 equals 方法相同对应的对象 hashCode 也相同。 toString：用字符串表示该对象 clone：深拷贝一个对象 简述内部类及其作用 成员内部类：作为成员对象的内部类。可以访问 private 及以上外部类的属性和方法。外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法。外部类也可访问 private 修饰的内部类属性。 局部内部类：存在于方法中的内部类。访问权限类似局部变量，只能访问外部类的 final 变量。 匿名内部类：只能使用一次，没有类名，只能访问外部类的 final 变量。 静态内部类：类似类的静态成员变量。 简述 String/StringBuffer 与 StringBuilderString 类采用利用 final 修饰的字符数组进行字符串保存，因此不可变。如果对 String 类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。 StringBuilder，采用无 final 修饰的字符数组进行保存，因此可变。但线程不安全。 StringBuffer，采用无 final 修饰的字符数组进行保存，可理解为实现线程安全的 StringBuilder。 简述 Java 序列化与反序列化的实现序列化：将 java 对象转化为字节序列，由此可以通过网络对象进行传输。 反序列化：将字节序列转化为 java 对象。 具体实现：实现 Serializable 接口，或实现 Externalizable 接口中的 writeExternal() 与 readExternal() 方法。 简述 JAVA 的 ListList 是一个有序队列，在 JAVA 中有两种实现方式: ArrayList 使用数组实现，是容量可变的非线程安全列表，随机访问快，集合扩容时会创建更大的数组，把原有数组复制到新数组。 LinkedList 本质是双向链表，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。 Java 中线程安全的基本数据结构有哪些HashTable：哈希表的线程安全版，效率低 ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代 HashTable Vector：线程安全版Arraylist Stack：线程安全版栈 BlockingQueue 及其子类：线程安全版队列 简述 JAVA 的 SetSet 即集合，该数据结构不允许元素重复且无序。JAVA 对 Set 有三种实现方式： HashSet 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，Value 系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较 hashCode，相同后再利用 equals 比较，查询 O(1) LinkedHashSet 继承自 HashSet，通过 LinkedHashMap 实现，使用双向链表维护元素插入顺序。 TreeSet 通过 TreeMap 实现的，底层数据结构是红黑树，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。查询 O(logn) 简述 JAVA 的 HashMapJDK8 之前底层实现是数组 + 链表，JDK8 改为数组 + 链表/红黑树。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。 HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个链表上。 table 数组记录 HashMap 的数据，每个下标对应一条链表，所有哈希冲突的数据都会被存放到同一条链表，Node/Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。在 JDK8 后链表超过 8 会转化为红黑树。 若当前数据/总数据容量&gt;负载因子，Hashmap 将执行扩容操作。 默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。 为何 HashMap 线程不安全在 JDK1.7 中，HashMap 采用头插法插入元素，因此并发情况下会导致环形链表，产生死循环。 虽然 JDK1.8 采用了尾插法解决了这个问题，但是并发下的 put 操作也会使前一个 key 被后一个 key 覆盖。 由于 HashMap 有扩容机制存在，也存在 A 线程进行扩容后，B 线程执行 get 方法出现失误的情况。 简述 Java 的 TreeMapTreeMap 是底层利用红黑树实现的 Map 结构，底层实现是一棵平衡的排序二叉树，由于红黑树的插入、删除、遍历时间复杂度都为 O(logN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树可以按照键的值的大小有序输出。 Collection 和 Collections 有什么区别？ Collection 是一个集合接口，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 List、Set 等。 Collections 是一个包装类，包含了很多静态方法、不能被实例化，而是作为工具类使用，比如提供的排序方法： Collections.sort(list),提供的反转方法：Collections.reverse(list)。 ArrayList、Vector 和 LinkedList 有什么共同点与区别？ ArrayList、Vector 和 LinkedList 都是可伸缩的数组，即可以动态改变长度的数组。 ArrayList 和 Vector 都是基于存储元素的 Object[] array 来实现的，它们会在内存中开辟一块连续的空间来存储，支持下标、索引访问。但在涉及插入元素时可能需要移动容器中的元素，插入效率较低。当存储元素超过容器的初始化容量大小，ArrayList 与 Vector 均会进行扩容。 Vector 是线程安全的，其大部分方法是直接或间接同步的。ArrayList 不是线程安全的，其方法不具有同步性质。LinkedList 也不是线程安全的。 LinkedList 采用双向列表实现，对数据索引需要从头开始遍历，因此随机访问效率较低，但在插入元素的时候不需要对数据进行移动，插入效率较高。 HashMap 和 Hashtable 有什么区别？ HashMap 是 Hashtable 的轻量级实现，HashMap 允许 key 和 value 为 null，但最多允许一条记录的 key 为 null。而 HashTable 不允许。 HashTable 中的方法是线程安全的，而 HashMap 不是。在多线程访问 HashMap 需要提供额外的同步机制。 Hashtable 使用 Enumeration 进行遍历，HashMap 使用 Iterator 进行遍历。 如何决定使用 HashMap 还是 TreeMap?如果对 Map 进行插入、删除或定位一个元素的操作更频繁，HashMap 是更好的选择。如果需要对key集合进行有序的遍历，TreeMap 是更好的选择。 fail-fast 和 fail-safe 迭代器的区别是什么？ fail-fast 直接在容器上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常见的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。 fail-safe 这种遍历基于容器的一个克隆。因此对容器中的内容修改不影响遍历。常见的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。 HashSet 中，equals 与 hashCode 之间的关系？equals 和 hashCode 这两个方法都是从 object 类中继承过来的,equals 主要用于判断对象的内存地址引用是否是同一个地址；hashCode 根据定义的哈希规则将对象的内存地址转换为一个哈希码。HashSet 中存储的元素是不能重复的，主要通过 hashCode 与 equals 两个方法来判断存储的对象是否相同： 如果两个对象的 hashCode 值不同，说明两个对象不相同。 如果两个对象的 hashCode 值相同，接着会调用对象的 equals 方法，如果 equlas 方法的返回结果为 true，那么说明两个对象相同，否则不相同。 拆箱装箱原理装箱过程是通过调用包装器的 valueOf 方法实现的，将原值赋给对应类。 拆箱过程是通过调用包装器的 intValue/doubleValue 等方法实现，返回基本的数据类型。 Java 反射原理Java 会在编译期装载所有的类，并将其元信息保存至 Class 类对象中。 因此可以设计 x.class/x.getClass()/Class.forName() 等方法获取 Class 对象。所以在反射调用 Field/Method/Constructor 对象时，可根据 Class 类对象进行进一步操作。 compator 和 compatable 的区别Comparable 是一个接口，用于对象内部的比较方式，该接口需要实现的方法是： 123public interface Comparable&lt;T&gt; { public int compareTo(T o);} Comapator 也是一个接口，该接口有个 compare 方法，该接口需要实现的方法是： 123public interface Comparator&lt;T&gt; { int compare(T o1, T o2);} 除该方法外，comparator 还可以实现其他方法。 动态代理实现方式 利用 JDK 反射机制，实现代理接口 利用 CGLib，对指定类生成子类，进行代理。 简述 OOM（out of memory）当 JVM 分配内存不够会抛出 out of memory 异常。 新建大对象时，容易出现 OOM 异常。 简述 StackOverFlowError调用栈深度超过限制产生的异常。 一般会在递归调用时出现，比如递归终止条件写的不对。 简述 ArrayList 扩容如果之前 ArrayList，添加新元素后的存储空间不够，ArrayList 会采用扩容机制，即在内存中申请原空间的 1.5 倍空间，并把原数组的值复制到新数组上，以此完成扩容。 Java 集 Collection 类型链表 List：ArrayList, Vector, LinkedList 集合 Set：Hashset, LinkedHashSet, TreeSet 表 Map：HashMap, TreeMap, HashTable Java 1.8 新特性 新增 lambda 表达式 新增函数式接口 新增 stream api hashmap 和 concurrenthashmap 实现底层优化 jvm 内存布局进行了修正，元数据区取代了永久代","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"基础知识","slug":"基础知识","permalink":"https://pass1on.fun/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Java-算法题解","slug":"Java-剑指offer题解","date":"2022-03-16T13:36:44.000Z","updated":"2022-03-24T09:26:29.023Z","comments":true,"path":"2022/03/16/Java-剑指offer题解/","link":"","permalink":"https://pass1on.fun/2022/03/16/Java-%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3/","excerpt":"Java-Leetcode 部分算法题解","text":"数组中重复的数字在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 2 &lt;= n &lt;= 100000 12345678910class Solution { public int findRepeatNumber(int[] nums) { Set&lt;Integer&gt; dic = new HashSet&lt;&gt;(); for(int num : nums) { if(dic.contains(num)) return num; dic.add(num); } return -1; }} 二维数组中的查找在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。 给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 1234567891011121314151617class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int rows = matrix.length, cols = matrix[0].length; int r = 0, c = cols - 1; // 从右上角开始 while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) { if (target == matrix[r][c]) return true; else if (target &gt; matrix[r][c]) r++; else c--; } return false; }} 替换空格请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 输入：s = “We are happy.”输出：”We%20are%20happy.” 限制： 0 &lt;= s 的长度 &lt;= 10000 1234567891011class Solution { public String replaceSpace(String s) { StringBuilder res = new StringBuilder(); for(Character c : s.toCharArray()) { if(c == ' ') res.append(\"%20\"); else res.append(c); } return res.toString(); }} 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2]输出：[2,3,1] 限制： 0 &lt;= 链表长度 &lt;= 10000 123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public int[] reversePrint(ListNode head) { LinkedList&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;(); while(head != null) { stack.addLast(head.val); head = head.next; } int[] res = new int[stack.size()]; for(int i = 0; i &lt; res.length; i++) res[i] = stack.removeLast(); return res; }} 连续子数组的最大和输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 提示： 1 &lt;= arr.length &lt;= 10^5-100 &lt;= arr[i] &lt;= 100 12345678910class Solution { public int maxSubArray(int[] nums) { int res = nums[0]; for(int i = 1; i &lt; nums.length; i++) { nums[i] += Math.max(nums[i - 1], 0); res = Math.max(res, nums[i]); } return res; }} LRU 缓存请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。实现 LRUCache 类：LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例： 输入[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4] 解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示： 1 &lt;= capacity &lt;= 30000 &lt;= key &lt;= 100000 &lt;= value &lt;= 105最多调用 2 * 105 次 get 和 put 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131public class LRUCache { //1.构建哈希 private Map&lt;Integer, DoubleLinkedNode&gt; cache = new HashMap&lt;&gt;(); //几个全局变量:链表大小，容量 private int size; private int capacity; //双向链表中，构造两个节点，伪头结点和伪尾节点，方便插入删除其他节点 private DoubleLinkedNode fakeHead; private DoubleLinkedNode fakeTail; //2.构建双向链表模型 class DoubleLinkedNode { //键值对 int key; int value; //前后节点 DoubleLinkedNode prev; DoubleLinkedNode next; //无参和有参构造 public DoubleLinkedNode() { } public DoubleLinkedNode(int k, int v) { this.key = k; this.value = v; } } //构造函数 public LRUCache(int capacity) { this.size = 0; this.capacity = capacity; fakeHead = new DoubleLinkedNode(); fakeTail = new DoubleLinkedNode(); fakeHead.next = fakeTail; fakeTail.prev = fakeHead; } //get方法 public int get(int key) { //1.查询哈希 DoubleLinkedNode node = cache.get(key); //为空返回-1 if (node == null) { return -1; } //2.哈希查询到，将该节点移动到头部 moveToHead(node); return node.value; } //put方法 public void put(int key, int value) { //1.哈希查询，若不存在节点，则添加 DoubleLinkedNode node = cache.get(key); if (node == null) { //创建节点，添加链表，添加哈希，增加size DoubleLinkedNode newNode = new DoubleLinkedNode(key, value); //新节点加入哈希 cache.put(key, newNode); //新节点加入头部 addToHead(newNode); ++size; //容量超出，在链表和哈希中删除尾节点 if (size &gt; capacity) { //不构造辅助方法的情况下直接删除，时间效率低// cache.remove(fakeTail.prev.key);// removeNode(fakeTail.prev); DoubleLinkedNode tail = removeTail(); cache.remove(tail.key); --size; }//若哈希中存在该节点，覆盖链表中的值，并更新该节点作为最近使用 } else { node.value = value; moveToHead(node); } } //辅助方法区： //1.将节点移动到头部 private void moveToHead(DoubleLinkedNode node) { //删除节点 removeNode(node); //头部添加该节点 addToHead(node); } //2.删除节点 private void removeNode(DoubleLinkedNode node) { node.prev.next = node.next; node.next.prev = node.prev; } //3.头部添加节点 private void addToHead(DoubleLinkedNode node) { node.prev = fakeHead; node.next = fakeHead.next; fakeHead.next.prev = node; fakeHead.next = node; } //4.删除尾节点，并返回被删除的节点 private DoubleLinkedNode removeTail(){ DoubleLinkedNode tail = fakeTail.prev; removeNode(tail); return tail; }}","categories":[{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"https://pass1on.fun/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://pass1on.fun/tags/Leetcode/"}]},{"title":"vue.js 使用 axios","slug":"vue-js-使用-axios","date":"2022-03-07T13:00:30.000Z","updated":"2022-03-07T13:20:29.692Z","comments":true,"path":"2022/03/07/vue-js-使用-axios/","link":"","permalink":"https://pass1on.fun/2022/03/07/vue-js-%E4%BD%BF%E7%94%A8-axios/","excerpt":"vue 安装使用 axios 以及 request.js 的封装","text":"安装 axiosnpm i axios -S request.js 封装12345678910111213141516171819202122232425262728293031323334353637383940414243import axios from 'axios'const request = axios.create({ baseURL: '/api', // 注意！！ 这里是全局统一加上了 '/api' 前缀，也就是说所有接口都会加上'/api'前缀在，页面里面写接口的时候就不要加 '/api'了，否则会出现2个'/api'，类似 '/api/api/user'这样的报错，切记！！！ timeout: 5000})// request 拦截器// 可以自请求发送前对请求做一些处理// 比如统一加token，对请求参数统一加密request.interceptors.request.use(config =&gt; { config.headers['Content-Type'] = 'application/json;charset=utf-8'; // config.headers['token'] = user.token; // 设置请求头 return config}, error =&gt; { return Promise.reject(error)});// response 拦截器// 可以在接口响应后统一处理结果request.interceptors.response.use( response =&gt; { let res = response.data; // 如果是返回的文件 if (response.config.responseType === 'blob') { return res } // 兼容服务端返回的字符串数据 if (typeof res === 'string') { res = res ? JSON.parse(res) : res } return res; }, error =&gt; { console.log('err' + error) // for debug return Promise.reject(error) })export default request 在 main.js 中引用 request 对象Vue.prototype.request=request","categories":[{"name":"过程记录","slug":"过程记录","permalink":"https://pass1on.fun/categories/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://pass1on.fun/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://pass1on.fun/tags/axios/"},{"name":"request.js","slug":"request-js","permalink":"https://pass1on.fun/tags/request-js/"}]},{"title":"npm 安装指定版本依赖","slug":"npm-安装指定版本依赖","date":"2022-03-07T11:15:08.000Z","updated":"2022-03-07T11:26:06.837Z","comments":true,"path":"2022/03/07/npm-安装指定版本依赖/","link":"","permalink":"https://pass1on.fun/2022/03/07/npm-%E5%AE%89%E8%A3%85%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96/","excerpt":"本文介绍 npm 安装依赖至指定版本的方法","text":"方法一先在 package.json 里修改好指定版本号，然后输入: npm update d3 方法二输入： npm update d3@5.15.0 会把 d3.js 更新至指定版本，但是不会写到 package.json 文件里，如果需要写到 package.json 里执行如下命令: npm update d3@5.15.0 --save 参考内容 淘宝镜像 npmjs 官网","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://pass1on.fun/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://pass1on.fun/tags/npm/"},{"name":"依赖","slug":"依赖","permalink":"https://pass1on.fun/tags/%E4%BE%9D%E8%B5%96/"}]},{"title":"Hexo+GithubPages-搭建博客","slug":"Hexo-GithubPages-搭建博客","date":"2021-12-31T11:59:39.000Z","updated":"2022-03-06T15:05:53.477Z","comments":true,"path":"2021/12/31/Hexo-GithubPages-搭建博客/","link":"","permalink":"https://pass1on.fun/2021/12/31/Hexo-GithubPages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","excerpt":"Hexo + Github Pages 简单快速搭建个人博客","text":"准备任务Github 账号注册一个 github 账号，并记住用户名与注册邮箱 Github 账号注册过程 Git 安装下载地址Git 下载 安装教程Git 安装教程 Node.js 安装下载地址Node.js 下载 安装教程Node.js 安装及环境配置教程 注意按照上述教程配置环境变量并验证是否安装成功 在命令行分别输入 1git --version 1node -v 1npm -v Typora 下载 （可选）Hexo 支持 Markdown 语法来写文章，推荐使用 Typora 作为文本编辑器 Typora 下载 Notepad++ 下载 （可选）在编辑配置文档的时候我们可以用 Notepad++ 来编辑文档 Notepad++ 下载与安装教程 创建 Github 仓库新建一个仓库 仓库名固定： 用户名.github.io 安装Hexo命令行输入 1npm install hexo-cli -g 验证安装是否成功 1hexo -v 绑定仓库进入任何一个文件夹中，在空白区域右键选择 Git Bash Here 在 git 命令行输入 ssh-keygen -t rsa -C \"注册 github 时所用邮箱\" 并敲 4 次回车 进入 C:\\Users\\你的用户名\\.ssh 文件夹 右键选中 id_rsa.pub 文件，选择使用 Notepad++ 打开 全选文件内容并复制 打开 GitHub 找到 Settings 选择 SSH and GPG keys 之后选择 New SSH key 在 Title 中输入任意内容，在 Key 中将刚才复制内容粘贴 在 git 命令行输入 ssh -T git@github.com 回答 yes 显示 Hi XXX! You've successfully...... 代表绑定成功 本地生成博客选择指定路径新建 Blog 文件夹作文博客本地仓库 在空白区域右键选择 Git Bash Here 在 git 命令行依次输入 1hexo init 1hexo g 1hexo s 打开浏览器输入 http://localhost:4000 查看效果 发布博客到互联网在刚才新建的 Blog 文件夹下，右键选择生成的 _config.yml 文件，选择使用 Notepad++ 打开 找到最后几行，将 12deploy: type: 选中删除 并在原位置输入 （注意是英文冒号，且冒号之后有空格） 1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: main 保存关闭 在 Blog 文件夹中在空白区域右键选择 Git Bash Here 在 git 命令行依次输入 1npm install hexo-deployer-git --save 1hexo g 1hexo d 验证你的 GitHub 账户 至此博客初步搭建过程结束，在浏览器输入 用户名.github.io 即可访问 参考内容 视频教程 Git 教程 Hexo 主题 Hexo 撰写文章教程 Hexo 文章加密教程 Fluid 主题","categories":[{"name":"过程记录","slug":"过程记录","permalink":"https://pass1on.fun/categories/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://pass1on.fun/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://pass1on.fun/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}]},{"title":"Python-合并多个csv文件","slug":"Python-合并多个csv文件","date":"2021-12-20T12:32:31.000Z","updated":"2022-03-06T15:06:21.908Z","comments":true,"path":"2021/12/20/Python-合并多个csv文件/","link":"","permalink":"https://pass1on.fun/2021/12/20/Python-%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcsv%E6%96%87%E4%BB%B6/","excerpt":"使用 Python 将文件夹下多个 .csv 文件合并","text":"代码123456789101112131415import globimport pandas as pdinputfile = \"文件夹路径\\*.csv\"outputfile = \"输出合并文件路径\\mergeResult.csv\"csv_list = glob.glob(inputfile)filepath = csv_list[0]df = pd.read_csv(filepath)df = df.to_csv(outputfile, index=False) #编码默认 UTF-8 ，若乱码自行更改for i in range(1, len(csv_list)): filepath = csv_list[i] df = pd.read_csv(filepath) df = df.to_csv(outputfile, index=False, header=False, mode='a+') 注意header=False 保证后续 .csv 文件是不保存列名的 参考内容Pandas 教程 Pandas 中文网","categories":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/tags/Python/"},{"name":"文件操作","slug":"文件操作","permalink":"https://pass1on.fun/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"csv","slug":"csv","permalink":"https://pass1on.fun/tags/csv/"},{"name":"Pandas","slug":"Pandas","permalink":"https://pass1on.fun/tags/Pandas/"}]},{"title":"Python-doc/docx/txt文件批量转换","slug":"Python-doc-docx-txt文件批量转换","date":"2021-12-19T06:55:21.000Z","updated":"2022-03-06T15:06:16.110Z","comments":true,"path":"2021/12/19/Python-doc-docx-txt文件批量转换/","link":"","permalink":"https://pass1on.fun/2021/12/19/Python-doc-docx-txt%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2/","excerpt":"使用 Python 实现 .doc/.docx/.txt 文件格式转换","text":"摘要 将文件夹中 doc 文件批量保存为 docx 文件 将文件夹中 docx 文件批量保存为 txt 文件 doc2docx作用python-docx 只能处理 Word2007 以后的版本 (.docx) 使用 python-docx 库读取文档前需要将 doc 文件保存为 docx 文件 代码12345678910111213141516171819202122from win32com import client as wcfrom pathlib import Pathimport osimport shutildoc_path = r\"D:\\workspace\\python\\KGProject\\syllabus\"temp_dir = \"temp\"if os.path.exists(f\"{doc_path}/{temp_dir}\"): shutil.rmtree(f\"{doc_path}/{temp_dir}\")os.mkdir(f\"{doc_path}/{temp_dir}\")word = wc.Dispatch(\"Word.Application\") try: for filename in Path(doc_path).glob(\"*.doc\"): file = str(filename) dest_name = str(filename.parent/f\"{temp_dir}\"/str(filename.name))+\"x\" print(file, dest_name) doc = word.Documents.Open(file) # 另存为后缀为 \".docx\" 的文件，其中参数 16 指 docx 文件 doc.SaveAs(dest_name, 16)finally: word.Quit() docx2txt作用将文档转换为 txt 文件方便处理纯文本数据 代码12345678910111213141516171819202122from win32com import client as wcfrom pathlib import Pathimport osimport shutildoc_path = r\"D:\\workspace\\python\\KGProject\\syllabus\"temp_dir = \"temp\"if os.path.exists(f\"{doc_path}/{temp_dir}\"): shutil.rmtree(f\"{doc_path}/{temp_dir}\")os.mkdir(f\"{doc_path}/{temp_dir}\")word = wc.Dispatch(\"Word.Application\") try: for filename in Path(doc_path).glob(\"*.docx\"): file = str(filename) dest_name = str(filename.parent/f\"{temp_dir}\"/str(filename.name[:-4]))+\"txt\" print(file, dest_name) doc = word.Documents.Open(file) # 另存为后缀为 \".txt\" 的文件，其中参数 2 指 txt 文件 doc.SaveAs(dest_name, 2)finally: word.Quit()","categories":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/tags/Python/"},{"name":"文件操作","slug":"文件操作","permalink":"https://pass1on.fun/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]}],"categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/categories/%E9%A2%98%E8%A7%A3/"},{"name":"过程记录","slug":"过程记录","permalink":"https://pass1on.fun/categories/%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"name":"问题解决","slug":"问题解决","permalink":"https://pass1on.fun/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/categories/Python/"}],"tags":[{"name":"八股文","slug":"八股文","permalink":"https://pass1on.fun/tags/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"学习记录","slug":"学习记录","permalink":"https://pass1on.fun/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://pass1on.fun/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","permalink":"https://pass1on.fun/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Redis","slug":"Redis","permalink":"https://pass1on.fun/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"https://pass1on.fun/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"操作系统","slug":"操作系统","permalink":"https://pass1on.fun/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://pass1on.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Java","slug":"Java","permalink":"https://pass1on.fun/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"https://pass1on.fun/tags/JVM/"},{"name":"多线程","slug":"多线程","permalink":"https://pass1on.fun/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"基础知识","slug":"基础知识","permalink":"https://pass1on.fun/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"题解","slug":"题解","permalink":"https://pass1on.fun/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"https://pass1on.fun/tags/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://pass1on.fun/tags/Leetcode/"},{"name":"Vue","slug":"Vue","permalink":"https://pass1on.fun/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"https://pass1on.fun/tags/axios/"},{"name":"request.js","slug":"request-js","permalink":"https://pass1on.fun/tags/request-js/"},{"name":"npm","slug":"npm","permalink":"https://pass1on.fun/tags/npm/"},{"name":"依赖","slug":"依赖","permalink":"https://pass1on.fun/tags/%E4%BE%9D%E8%B5%96/"},{"name":"Hexo","slug":"Hexo","permalink":"https://pass1on.fun/tags/Hexo/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://pass1on.fun/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"Python","slug":"Python","permalink":"https://pass1on.fun/tags/Python/"},{"name":"文件操作","slug":"文件操作","permalink":"https://pass1on.fun/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"csv","slug":"csv","permalink":"https://pass1on.fun/tags/csv/"},{"name":"Pandas","slug":"Pandas","permalink":"https://pass1on.fun/tags/Pandas/"}]}